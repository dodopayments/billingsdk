{
  "name": "fastify-stripe",
  "description": "Stripe template for Fastify",
  "framework": "fastify",
  "files": [
    {
      "target": "lib/stripe.ts",
      "type": "template",
      "content": "import Stripe from 'stripe';\n\nlet _stripe: Stripe | null = null;\nexport const getStripe = (): Stripe => {\n  const key = process.env.STRIPE_SECRET_KEY;\n  if(!key){\n    throw new Error(\"STRIPE_SECRET_KEY is not set\")\n  }\n  if (!_stripe) {\n    _stripe = new Stripe(process.env.STRIPE_SECRET_KEY as string, {\n      \n    });\n  }\n  return _stripe;\n};\n\n\n\nlet stripe = getStripe();\n\n\nexport type Product = Stripe.Product;\nexport type Customer = Stripe.Customer;\nexport type Subscription = Stripe.Subscription;\nexport type PaymentIntent = Stripe.PaymentIntent;\n\n\nexport async function getProducts(): Promise<Product[]> {\n  try {\n    const { data } = await stripe.products.list({ limit: 100 });\n    return data;\n  } catch (error) {\n    console.error('Error fetching products', error);\n    throw new Error('Failed to fetch products');\n  }\n}\n\nexport async function getProduct(product_id: string): Promise<Product> {\n  try {\n    return await stripe.products.retrieve(product_id);\n  } catch (error) {\n    console.error('Error fetching product', error);\n    throw new Error('Failed to fetch product');\n  }\n}\n\n\nexport async function getCustomer(customer_id: string): Promise<Customer | Stripe.DeletedCustomer> {\n  try {\n    const customer = await stripe.customers.retrieve(customer_id);\n    \n    if ((customer as Stripe.DeletedCustomer).deleted) {\n      return customer as Stripe.DeletedCustomer;\n    }\n    return customer as Customer;\n  } catch (error) {\n    console.error('Error fetching customer', error);\n    throw new Error('Failed to fetch customer');\n  }\n}\n\nexport async function createCustomer(params: Stripe.CustomerCreateParams): Promise<Customer> {\n  try {\n    return await stripe.customers.create(params);\n  } catch (error) {\n    console.error('Error creating customer', error);\n    throw new Error('Failed to create customer');\n  }\n}\n\nexport async function updateCustomer(customer_id: string, params: Stripe.CustomerUpdateParams): Promise<Customer> {\n  try {\n    return await stripe.customers.update(customer_id, params);\n  } catch (error) {\n    console.error('Error updating customer', error);\n    throw new Error('Failed to update customer');\n  }\n}\n\n\nexport async function getCustomerSubscriptions(customer_id: string): Promise<Subscription[]> {\n  try {\n    const { data } = await stripe.subscriptions.list({ customer: customer_id });\n    return data;\n  } catch (error) {\n    console.error('Error fetching subscriptions', error);\n    throw new Error('Failed to fetch subscriptions');\n  }\n}\n\n\nexport async function getCustomerPayments(customer_id: string): Promise<PaymentIntent[]> {\n  try {\n    const { data } = await stripe.paymentIntents.list({ customer: customer_id, limit: 100 });\n    return data;\n  } catch (error) {\n    console.error('Error fetching payments', error);\n    throw new Error('Failed to fetch payments');\n  }\n}\n\n\nexport async function checkout(opts: {\n  price_id: string;\n  customer_id?: string;\n  success_url: string;\n  cancel_url: string;\n}): Promise<{ checkout_url: string }> {\n  try {\n    const session = await stripe.checkout.sessions.create({\n      mode: 'subscription',\n      line_items: [{ price: opts.price_id, quantity: 1 }],\n      customer: opts.customer_id ?? '',\n      success_url: opts.success_url,\n      cancel_url: opts.cancel_url,\n    });\n    return { checkout_url: session.url! };\n  } catch (error) {\n    console.error('Error creating checkout session', error);\n    throw new Error('Failed to create checkout session');\n  }\n}\n"
    },
    {
      "target": "routes/stripe/route.ts",
      "type": "template",
      "content": "// @ts-nocheck\nimport { FastifyInstance } from 'fastify'\nimport checkoutRoutes from './checkout'\nimport customerRoutes from './customer'\nimport paymentsRoutes from './payments'\nimport productsRoutes from './products'\nimport subscriptionsRoutes from './subscriptions'\nimport webhookRoutes from './webhook'\n\nexport default async function stripeRoutes(fastify: FastifyInstance) {\n  await fastify.register(checkoutRoutes, { prefix: '/checkout' })\n  await fastify.register(customerRoutes, { prefix: '/customer' })\n  await fastify.register(paymentsRoutes, { prefix: '/payments' })\n  await fastify.register(productsRoutes, { prefix: '/products' })\n  await fastify.register(subscriptionsRoutes, { prefix: '/subscriptions' })\n  await fastify.register(webhookRoutes, { prefix: '/webhook' })\n}\n"
    },
    {
      "target": "routes/stripe/checkout.ts",
      "type": "template",
      "content": "// @ts-nocheck\nimport { FastifyInstance } from 'fastify'\nimport { z } from 'zod'\nimport { getStripe } from '../../lib/stripe';\nimport type Stripe from 'stripe';\n\nconst stripe = getStripe();\n\nexport default async function checkoutRoutes(fastify: FastifyInstance) {\n  const productCartItemSchema = z.object({\n    price_id: z.string().min(1, \"Price ID is required\"),\n    quantity: z.number().int().min(1, \"Quantity must be at least 1\"),\n  });\n\n  const attachExistingCustomerSchema = z.object({\n    customer_id: z.string().min(1, \"Customer ID is required\"),\n  });\n\n  const newCustomerSchema = z.object({\n    email: z.string().email(\"Invalid email format\"),\n    name: z.string().min(1, \"Name is required\"),\n    phone_number: z.string().optional().nullable(),\n    create_new_customer: z.boolean().optional(),\n  });\n\n  const customerSchema = z.union([attachExistingCustomerSchema, newCustomerSchema]);\n\n  const checkoutSessionSchema = z.object({\n    productCart: z.array(productCartItemSchema).min(1, \"At least one product is required\"),\n    customer: customerSchema.optional(),\n    success_url: z.string().url(\"Success URL must be a valid URL\"),\n    cancel_url: z.string().url(\"Cancel URL must be a valid URL\"),\n    metadata: z.record(z.string(), z.string()).optional(),\n  });\n\n  fastify.post('/', async (request, reply) => {\n    try {\n      const validationResult = checkoutSessionSchema.safeParse(request.body)\n      if (!validationResult.success) {\n        return reply.status(400).send({\n          error: 'Validation failed',\n          details: validationResult.error.issues.map((issue) => ({\n            field: issue.path.join('.'),\n            message: issue.message,\n          })),\n        })\n      }\n\n      const { productCart, customer, success_url, cancel_url, metadata } = validationResult.data;\n\n      let customerId: string | undefined;\n      if (customer && 'email' in customer) {\n        const stripeCustomer = await stripe.customers.create({\n          email: customer.email ?? \"\",\n          name: customer.name ?? \"\",\n          phone: customer.phone_number ?? \"\",\n        });\n        customerId = stripeCustomer.id;\n      } else if (customer && 'customer_id' in customer) {\n        customerId = customer.customer_id;\n      }\n\n      const sessionParams: Stripe.Checkout.SessionCreateParams = {\n        payment_method_types: [\"card\"],\n        line_items: productCart.map(item => ({\n          price: item.price_id,\n          quantity: item.quantity,\n        })),\n        mode: \"payment\",\n        success_url: success_url + \"?session_id={CHECKOUT_SESSION_ID}\",\n        cancel_url: cancel_url,\n\n        ...(metadata ? { metadata } : {}),\n      };\n\n      if (customerId) {\n        sessionParams.customer = customerId;\n      }\n\n      const session = await stripe.checkout.sessions.create(sessionParams);\n\n      return reply.send({ url: session.url })\n    } catch (error) {\n      console.error('Stripe checkout error:', error);\n      return reply.status(500).send({ error: 'Internal server error' })\n    }\n  })\n}\n"
    },
    {
      "target": "routes/stripe/customer.ts",
      "type": "template",
      "content": "// @ts-nocheck\nimport { FastifyInstance } from 'fastify'\nimport { z } from 'zod'\nimport type Stripe from 'stripe';\nimport { getStripe } from '../../lib/stripe';\n\nconst stripe = getStripe();\n\nexport default async function customerRoutes(fastify: FastifyInstance) {\n  const customerCreateSchema = z.object({\n    email: z.string().email('Invalid email format'),\n    name: z.string().min(1, 'Name is required'),\n    phone_number: z.string().optional().nullable(),\n  })\n\n  const customerUpdateSchema = z.object({\n    email: z.string().email('Invalid email format').optional(),\n    name: z.string().min(1, 'Name is required').optional(),\n    phone_number: z.string().optional().nullable(),\n  })\n\n  fastify.get('/', async (request, reply) => {\n    try {\n      const { customer_id } = request.query as Record<string, any>\n      if (!customer_id || typeof customer_id !== 'string') {\n        return reply.status(400).send({ error: 'customer_id is required' })\n      }\n      const customer = await stripe.customers.retrieve(customer_id)\n      return reply.send(customer)\n    } catch (error) {\n      console.error('Error fetching customer:', error);\n      return reply.status(500).send({ error: 'Internal server error' })\n    }\n  })\n\n  fastify.post('/', async (request, reply) => {\n    try {\n      const validationResult = customerCreateSchema.safeParse(request.body)\n      if (!validationResult.success) {\n        return reply.status(400).send({\n          error: 'Validation failed',\n          details: validationResult.error.issues.map((issue) => ({\n            field: issue.path.join('.'),\n            message: issue.message,\n          })),\n        })\n      }\n\n      const customer = await stripe.customers.create({\n        email: validationResult.data.email,\n        name: validationResult.data.name,\n        phone: validationResult.data.phone_number ?? \"\",\n      });\n\n      return reply.send(customer)\n    } catch (error) {\n      console.error('Error creating customer:', error);\n      return reply.status(500).send({ error: 'Internal server error' })\n    }\n  })\n\n  fastify.put('/', async (request, reply) => {\n    try {\n      const { customer_id } = request.query as Record<string, any>\n      if (!customer_id || typeof customer_id !== 'string') {\n        return reply.status(400).send({ error: 'customer_id is required' })\n      }\n\n      const validationResult = customerUpdateSchema.safeParse(request.body)\n      if (!validationResult.success) {\n        return reply.status(400).send({\n          error: 'Validation failed',\n          details: validationResult.error.issues.map((issue) => ({\n            field: issue.path.join('.'),\n            message: issue.message,\n          })),\n        })\n      }\n\n      const updateData: Stripe.CustomerUpdateParams = {};\n      if (validationResult.data.email) updateData.email = validationResult.data.email;\n      if (validationResult.data.name) updateData.name = validationResult.data.name;\n      if (validationResult.data.phone_number) updateData.phone = validationResult.data.phone_number;\n\n      const customer = await stripe.customers.update(customer_id, updateData);\n      return reply.send(customer)\n    } catch (error) {\n      console.error('Error updating customer:', error);\n      return reply.status(500).send({ error: 'Internal server error' })\n    }\n  })\n\n  fastify.get('/subscriptions', async (request, reply) => {\n    try {\n      const { customer_id } = request.query as Record<string, any>\n      if (!customer_id || typeof customer_id !== 'string') {\n        return reply.status(400).send({ error: 'customer_id is required' })\n      }\n\n      const subscriptions = await stripe.subscriptions.list({\n        customer: customer_id,\n        limit: 100,\n      });\n\n      return reply.send(subscriptions.data)\n    } catch (error) {\n      console.error('Error fetching customer subscriptions:', error);\n      return reply.status(500).send({ error: 'Internal server error' })\n    }\n  })\n\n  fastify.get('/payments', async (request, reply) => {\n    try {\n      const { customer_id } = request.query as Record<string, any>\n      if (!customer_id || typeof customer_id !== 'string') {\n        return reply.status(400).send({ error: 'customer_id is required' })\n      }\n\n      const payments = await stripe.paymentIntents.list({\n        customer: customer_id,\n        limit: 100,\n      });\n\n      return reply.send(payments)\n    } catch (error) {\n      console.error('Error fetching customer payments:', error);\n      return reply.status(500).send({ error: 'Internal server error' })\n    }\n  })\n}\n"
    },
    {
      "target": "routes/stripe/payments.ts",
      "type": "template",
      "content": "// @ts-nocheck\nimport { FastifyInstance } from 'fastify'\nimport { getStripe } from '../../lib/stripe';\n\nconst stripe = getStripe();\n\nexport default async function paymentsRoutes(fastify: FastifyInstance) {\n  fastify.get('/', async (request, reply) => {\n    try {\n      const { payment_id } = request.query as Record<string, any>\n      if (!payment_id || typeof payment_id !== 'string') {\n        return reply.status(400).send({ error: 'payment_id is required' })\n      }\n      const payment = await stripe.paymentIntents.retrieve(payment_id)\n      return reply.send(payment)\n    } catch (error) {\n      console.error('Error fetching payment:', error);\n      return reply.status(500).send({ error: 'Internal server error' })\n    }\n  })\n\n  fastify.get('/list', async (request, reply) => {\n    try {\n      const { customer_id, limit, starting_after } = request.query as Record<string, any>\n      if (customer_id && typeof customer_id === 'string') {\n        params.customer_id = customer_id;\n      }\n      if (limit && typeof limit === 'string') {\n        params.limit = parseInt(limit);\n      }\n      if (starting_after && typeof starting_after === 'string') {\n        params.starting_after = starting_after;\n      }\n\n      const payments = await stripe.paymentIntents.list(params)\n      return reply.send(payments.data)\n    } catch (error) {\n      console.error('Error fetching payments list:', error);\n      return reply.status(500).send({ error: 'Internal server error' })\n    }\n  })\n}\n"
    },
    {
      "target": "routes/stripe/products.ts",
      "type": "template",
      "content": "// @ts-nocheck\nimport { FastifyInstance } from 'fastify'\nimport { getStripe } from '../../lib/stripe';\nimport type Stripe from 'stripe';\n\nconst stripe = getStripe();\n\nexport default async function productsRoutes(fastify: FastifyInstance) {\n  fastify.get('/', async (request, reply) => {\n    try {\n      const { limit, starting_after } = request.query as Record<string, any>\n      const params: Stripe.ProductListParams = {};\n      if (limit && typeof limit === 'string') {\n        const parsed = parseInt(limit, 10);\n        if (!isNaN(parsed)) params.limit = parsed;\n      }\n\n      if (starting_after && typeof starting_after === 'string') {\n        params.starting_after = starting_after;\n      }\n\n\n      const products = await stripe.products.list(params);\n      return reply.send(products.data);\n    } catch (error) {\n      console.error('Error fetching products:', error);\n      return reply.status(500).send({ error: 'Internal server error' })\n    }\n  })\n\n  fastify.get('/product', async (request, reply) => {\n    try {\n      const { product_id } = request.query as Record<string, any>\n      if (!product_id || typeof product_id !== 'string') {\n        return reply.status(400).send({ error: 'product_id is required' })\n      }\n\n      const product = await stripe.products.retrieve(product_id)\n      return reply.send(product)\n    } catch (error) {\n      console.error('Error fetching product:', error);\n      return reply.status(500).send({ error: 'Internal server error' })\n    }\n  })\n}\n"
    },
    {
      "target": "routes/stripe/subscriptions.ts",
      "type": "template",
      "content": "import { FastifyInstance } from 'fastify'\nimport { getStripe } from '../../lib/stripe';\nimport type Stripe from 'stripe';\n\nconst stripe = getStripe();\n\nexport default async function subscriptionsRoutes(fastify: FastifyInstance) {\n  fastify.get('/', async (request, reply) => {\n    try {\n      const { subscription_id } = request.query as Record<string, any>\n      if (!subscription_id || typeof subscription_id !== 'string') {\n        return reply.status(400).send({ error: 'subscription_id is required' })\n      }\n      const subscription = await stripe.subscriptions.retrieve(subscription_id)\n      return reply.send(subscription)\n    } catch (error) {\n      console.error('Error fetching subscription:', error);\n      return reply.status(500).send({ error: 'Internal server error' })\n    }\n  })\n\n  fastify.get('/list', async (request, reply) => {\n    try {\n      const { customer_id, limit, starting_after } = request.query as Record<string, any>\n\n      if (!customer_id || typeof customer_id !== 'string') {\n        return reply.status(400).send({ error: 'customer_id is required' });\n      }\n\n      const params: Stripe.SubscriptionListParams = {\n        customer: customer_id,\n      };\n\n      if (limit && typeof limit === 'string') {\n        const parsed = parseInt(limit, 10);\n        if (!isNaN(parsed)) params.limit = parsed;\n      }\n\n      if (starting_after && typeof starting_after === 'string') {\n        params.starting_after = starting_after;\n      }\n\n      const subscriptions = await stripe.subscriptions.list(params);\n      return reply.send(subscriptions.data)\n    } catch (error) {\n      console.error('Error fetching subscriptions list:', error);\n      return reply.status(500).send({ error: 'Internal server error' })\n    }\n  })\n}\n"
    },
    {
      "target": "routes/stripe/webhook.ts",
      "type": "template",
      "content": "// @ts-nocheck\nimport { FastifyInstance } from 'fastify'\nimport Stripe from 'stripe';\nimport { getStripe } from '../../lib/stripe';\n\nconst stripe = getStripe();\n\nexport default async function webhookRoutes(fastify: FastifyInstance) {\n  fastify.post('/', {\n    // Note: To get the raw body reliably, register `fastify-raw-body` in your Fastify app:\n    // await fastify.register(import('fastify-raw-body'), { field: 'rawBody', global: false, encoding: 'utf8', runFirst: true })\n    // and enable it for this route via `config: { rawBody: true }`.\n    config: { rawBody: true }\n  }, async (request, reply) => {\n    try {\n      // Prefer rawBody provided by fastify-raw-body; fallback to re-serializing parsed body\n      const rawBody: any = (request as any).rawBody ?? JSON.stringify(request.body ?? {})\n\n      const sig = request.headers['stripe-signature'] as string | undefined;\n      if (!sig) {\n        return reply.status(400).send({ error: 'Missing Stripe signature' });\n      }\n\n      const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET!;\n      let event: Stripe.Event;\n\n      try {\n        event = stripe.webhooks.constructEvent(rawBody, sig, webhookSecret);\n      } catch (err) {\n        console.error('Webhook signature verification failed:', err);\n        return reply.status(400).send({ error: 'Webhook verification failed' });\n      }\n\n      // Emit logs for reference; users can replace with their business logic\n      switch (event.type) {\n\n        case 'customer.subscription.created':\n        case 'customer.subscription.updated':\n        case 'customer.subscription.deleted': {\n          const subscription = event.data.object as Stripe.Subscription;\n          console.log('Subscription event:', event.type, subscription.id);\n          break;\n        }\n\n\n        case 'payment_intent.succeeded': {\n          const paymentIntent = event.data.object as Stripe.PaymentIntent;\n          console.log('Payment succeeded:', paymentIntent.id, paymentIntent.amount);\n          break;\n        }\n\n        case 'payment_intent.payment_failed': {\n          const paymentIntent = event.data.object as Stripe.PaymentIntent;\n          console.log('Payment failed:', paymentIntent.id, paymentIntent.last_payment_error);\n          break;\n        }\n\n        case 'charge.refunded': {\n          const charge = event.data.object as Stripe.Charge;\n          console.log('Charge refunded:', charge.id, charge.amount_refunded);\n          break;\n        }\n\n        default:\n          console.log('Unhandled event type:', event.type);\n          break;\n      }\n\n      return reply.status(200).send({ message: 'Webhook processed successfully' })\n    } catch (error) {\n      console.error('Webhook verification failed:', error);\n      return reply.status(400).send({ error: 'Webhook verification failed' })\n    }\n  })\n}\n"
    },
    {
      "target": ".env.example",
      "type": "template",
      "content": "# DodoPayments Configuration\nDODO_PAYMENTS_API_KEY=your_api_key_here\nDODO_PAYMENTS_ENVIRONMENT=test_mode\nDODO_PAYMENTS_WEBHOOK_KEY=your_webhook_key_here\n\n# Server Configuration\nPORT=3000\nNODE_ENV=development\n"
    }
  ],
  "dependencies": [
    "stripe",
    "standardwebhooks",
    "zod",
    "fastify",
    "fastify-raw-body"
  ]
}