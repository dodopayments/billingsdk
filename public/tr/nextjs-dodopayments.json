{
  "name": "nextjs-dodopayments",
  "description": "DodoPayments template for NextJS",
  "framework": "nextjs",
  "files": [
    {
      "target": "lib/dodopayments.ts",
      "type": "template",
      "content": "import { DodoPayments } from 'dodopayments'\r\ntype Product = DodoPayments.Product\r\n\r\nlet dodopaymentsClient: DodoPayments | null = null\r\n\r\nexport function getDodoPaymentsClient(): DodoPayments {\r\n  if (!dodopaymentsClient) {\r\n    const token = process.env.DODO_PAYMENTS_API_KEY\r\n    const environment = process.env.DODO_PAYMENTS_ENVIRONMENT as \"live_mode\" | \"test_mode\"\r\n\r\n    console.log('Initializing DodoPayments client...')\r\n    console.log('Token exists:', !!token)\r\n    console.log('Environment:', environment)\r\n\r\n    if (!token) {\r\n      throw new Error(`\r\n        DODO_PAYMENTS_API_KEY environment variable is missing.\r\n        \r\n        Please check:\r\n        1. Your .env.local file exists in the project root\r\n        2. The file contains: DODO_PAYMENTS_API_KEY=<your-api-key>\r\n        3. You've restarted your development server\r\n        4. No extra quotes or spaces in the .env.local file\r\n      `)\r\n    }\r\n\r\n    if (!environment || (environment !== \"live_mode\" && environment !== \"test_mode\")) {\r\n      throw new Error('DODO_PAYMENTS_ENVIRONMENT must be either \"live_mode\" or \"test_mode\"')\r\n    }\r\n\r\n    dodopaymentsClient = new DodoPayments({\r\n      bearerToken: token,\r\n      environment: environment,\r\n    })\r\n  }\r\n\r\n  return dodopaymentsClient\r\n}\r\n\r\nexport const getProducts = async (): Promise<Product[]> => {\r\n  try {\r\n    const response = await fetch('/api/products')\r\n\r\n    if (!response.ok) {\r\n      throw new Error(`Failed to fetch products: ${response.status} ${response.statusText}`)\r\n    }\r\n\r\n    return await response.json()\r\n  } catch (error) {\r\n    console.error('Error fetching products:', error)\r\n    throw error\r\n  }\r\n}\r\n\r\nexport const getProduct = async (product_id: string): Promise<Product> => {\r\n  try {\r\n    const response = await fetch(`/api/product?product_id=${product_id}`)\r\n\r\n    if (!response.ok) {\r\n      throw new Error(`Failed to fetch product: ${response.status} ${response.statusText}`)\r\n    }\r\n\r\n    return await response.json()\r\n  } catch (error) {\r\n    console.error('Error fetching product:', error)\r\n    throw error\r\n  }\r\n}\r\n\r\nexport const getCustomer = async (customer_id: string): Promise<DodoPayments.Customers.Customer> => {\r\n  try {\r\n    const response = await fetch(`/api/customer?customer_id=${customer_id}`)\r\n\r\n    if (!response.ok) {\r\n      throw new Error(`Failed to fetch customer: ${response.status} ${response.statusText}`)\r\n    }\r\n\r\n    return await response.json()\r\n  } catch (error) {\r\n    console.error('Error fetching customer:', error)\r\n    throw error\r\n  }\r\n}\r\n\r\nexport const getCustomerSubscriptions = async (customer_id: string): Promise<DodoPayments.Subscriptions.Subscription[]> => {\r\n  try {\r\n    const response = await fetch(`/api/customer/subscriptions?customer_id=${customer_id}`)\r\n\r\n    if (!response.ok) {\r\n      throw new Error(`Failed to fetch customer subscriptions: ${response.status} ${response.statusText}`)\r\n    }\r\n\r\n    return await response.json()\r\n  } catch (error) {\r\n    console.error('Error fetching customer subscriptions:', error)\r\n    throw error\r\n  }\r\n}\r\n\r\nexport const getCustomerPayments = async (customer_id: string): Promise<DodoPayments.Payments.Payment[]> => {\r\n  try {\r\n    const response = await fetch(`/api/customer/payments?customer_id=${customer_id}`)\r\n\r\n    if (!response.ok) {\r\n      throw new Error(`Failed to fetch customer payments: ${response.status} ${response.statusText}`)\r\n    }\r\n\r\n    return await response.json()\r\n  } catch (error) {\r\n    console.error('Error fetching customer payments:', error)\r\n    throw error\r\n  }\r\n}\r\n\r\nexport const createCustomer = async (customer: DodoPayments.Customers.CustomerCreateParams): Promise<DodoPayments.Customers.Customer> => {\r\n  try {\r\n    const response = await fetch('/api/customer', {\r\n      method: 'POST',\r\n      body: JSON.stringify(customer),\r\n    })\r\n\r\n    if (!response.ok) {\r\n      throw new Error(`Failed to create customer: ${response.status} ${response.statusText}`)\r\n    }\r\n\r\n    return await response.json()\r\n  } catch (error) {\r\n    console.error('Error creating customer:', error)\r\n    throw error\r\n  }\r\n}\r\n\r\nexport const updateCustomer = async (customer_id: string, customer: DodoPayments.Customers.CustomerUpdateParams): Promise<DodoPayments.Customers.Customer> => {\r\n  try {\r\n    const response = await fetch(`/api/customer?customer_id=${customer_id}`, {\r\n      method: 'PUT',\r\n      body: JSON.stringify(customer),\r\n    })\r\n\r\n    if (!response.ok) {\r\n      throw new Error(`Failed to update customer: ${response.status} ${response.statusText}`)\r\n    }\r\n\r\n    return await response.json()\r\n  } catch (error) {\r\n    console.error('Error updating customer:', error)\r\n    throw error\r\n  }\r\n}\r\n\r\nexport const checkout = async (productCart: Array<{ product_id: string; quantity: number; amount?: number }>, customer: DodoPayments.Payments.CustomerRequest, billing_address: DodoPayments.Payments.BillingAddress, return_url: string, customMetadata?: Record<string, string>) => {\r\n  try {\r\n    const response = await fetch('/api/checkout', {\r\n      method: 'POST',\r\n      body: JSON.stringify({ productCart, customer, billing_address, return_url, customMetadata }),\r\n    })\r\n\r\n    if (!response.ok) {\r\n      throw new Error(`Failed to checkout: ${response.status} ${response.statusText}`)\r\n    }\r\n\r\n    return await response.json()\r\n  } catch (error) {\r\n    console.error('Error checking out:', error)\r\n    throw error\r\n  }\r\n}"
    },
    {
      "target": "hooks/useBilling.ts",
      "type": "template",
      "content": "'use client'\r\n\r\nimport { useState, useCallback } from 'react'\r\nimport { DodoPayments } from 'dodopayments'\r\nimport {\r\n  getProducts,\r\n  getProduct,\r\n  getCustomer,\r\n  getCustomerSubscriptions,\r\n  getCustomerPayments,\r\n  createCustomer,\r\n  updateCustomer,\r\n  checkout,\r\n} from '@/lib/dodopayments'\r\n\r\ninterface UseBillingState {\r\n  loading: boolean\r\n  error: string | null\r\n}\r\n\r\nexport const useBilling = () => {\r\n  const [state, setState] = useState<UseBillingState>({\r\n    loading: false,\r\n    error: null,\r\n  })\r\n\r\n  const setLoading = useCallback((loading: boolean) => {\r\n    setState(prev => ({ ...prev, loading }))\r\n  }, [])\r\n\r\n  const setError = useCallback((error: string | null) => {\r\n    setState(prev => ({ ...prev, error }))\r\n  }, [])\r\n\r\n  const handleAsyncOperation = useCallback(async <T>(\r\n    operation: () => Promise<T>,\r\n    operationName: string\r\n  ): Promise<T> => {\r\n    try {\r\n      setLoading(true)\r\n      setError(null)\r\n      const result = await operation()\r\n      return result\r\n    } catch (error) {\r\n      const errorMessage = error instanceof Error ? error.message : `Failed to ${operationName}`\r\n      setError(errorMessage)\r\n      throw error\r\n    } finally {\r\n      setLoading(false)\r\n    }\r\n  }, [])\r\n\r\n  const fetchProducts = useCallback(async () => {\r\n    return handleAsyncOperation(() => getProducts(), 'fetch products')\r\n  }, [handleAsyncOperation])\r\n\r\n  const fetchProduct = useCallback(async (product_id: string) => {\r\n    return handleAsyncOperation(() => getProduct(product_id), 'fetch product')\r\n  }, [handleAsyncOperation])\r\n\r\n  const fetchCustomer = useCallback(async (customer_id: string) => {\r\n    return handleAsyncOperation(() => getCustomer(customer_id), 'fetch customer')\r\n  }, [handleAsyncOperation])\r\n\r\n  const fetchCustomerSubscriptions = useCallback(async (customer_id: string) => {\r\n    return handleAsyncOperation(() => getCustomerSubscriptions(customer_id), 'fetch customer subscriptions')\r\n  }, [handleAsyncOperation])\r\n\r\n  const fetchCustomerPayments = useCallback(async (customer_id: string) => {\r\n    return handleAsyncOperation(() => getCustomerPayments(customer_id), 'fetch customer payments')\r\n  }, [handleAsyncOperation])\r\n\r\n  const createNewCustomer = useCallback(async (customer: DodoPayments.Customers.CustomerCreateParams) => {\r\n    return handleAsyncOperation(() => createCustomer(customer), 'create customer')\r\n  }, [handleAsyncOperation])\r\n\r\n  const updateExistingCustomer = useCallback(async (\r\n    customer_id: string,\r\n    customer: DodoPayments.Customers.CustomerUpdateParams\r\n  ) => {\r\n    return handleAsyncOperation(() => updateCustomer(customer_id, customer), 'update customer')\r\n  }, [handleAsyncOperation])\r\n\r\n  const createCheckout = useCallback(async (\r\n    productCart: Array<{ product_id: string; quantity: number; amount?: number }>,\r\n    customer: DodoPayments.Payments.CustomerRequest,\r\n    billing_address: DodoPayments.Payments.BillingAddress,\r\n    return_url: string,\r\n    customMetadata?: Record<string, string>\r\n  ) => {\r\n    return handleAsyncOperation(\r\n      () => checkout(productCart, customer, billing_address, return_url, customMetadata),\r\n      'create checkout'\r\n    )\r\n  }, [handleAsyncOperation])\r\n\r\n  const clearError = useCallback(() => {\r\n    setError(null)\r\n  }, [setError])\r\n\r\n  return {\r\n    // State\r\n    loading: state.loading,\r\n    error: state.error,\r\n\r\n    // Actions\r\n    clearError,\r\n\r\n    // Product operations\r\n    fetchProducts,\r\n    fetchProduct,\r\n\r\n    // Customer operations\r\n    fetchCustomer,\r\n    fetchCustomerSubscriptions,\r\n    fetchCustomerPayments,\r\n    createNewCustomer,\r\n    updateExistingCustomer,\r\n\r\n    // Checkout operations\r\n    createCheckout,\r\n  }\r\n}\r\n"
    },
    {
      "target": "app\\api\\(dodopayments)\\checkout\\route.ts",
      "type": "template",
      "content": "import { getDodoPaymentsClient } from \"@/lib/dodopayments\";\r\nimport { DodoPayments } from \"dodopayments\";\r\nimport { NextResponse } from \"next/server\";\r\nimport { z } from \"zod\";\r\n\r\nconst productCartItemSchema = z.object({\r\n    product_id: z.string().min(1, \"Product ID is required\"),\r\n    quantity: z.number().int().min(1, \"Quantity must be at least 1\"),\r\n    amount: z.number().int().min(0).optional(),\r\n});\r\n\r\nconst attachExistingCustomerSchema = z.object({\r\n    customer_id: z.string().min(1, \"Customer ID is required\"),\r\n});\r\n\r\nconst newCustomerSchema = z.object({\r\n    email: z.string().email(\"Invalid email format\"),\r\n    name: z.string().min(1, \"Name is required\"),\r\n    phone_number: z.string().optional().nullable(),\r\n    create_new_customer: z.boolean().optional(),\r\n});\r\n\r\nconst customerSchema = z.union([attachExistingCustomerSchema, newCustomerSchema]);\r\n\r\nconst billingAddressSchema = z.object({\r\n    city: z.string().min(1, \"City is required\"),\r\n    country: z.string().regex(/^[A-Z]{2}$/, \"Country must be a 2-letter uppercase ISO code\"),\r\n    state: z.string().min(1, \"State is required\"),\r\n    street: z.string().min(1, \"Street address is required\"),\r\n    zipcode: z.string().min(1, \"Zipcode is required\"),\r\n});\r\n\r\nconst checkoutSessionSchema = z.object({\r\n    productCart: z.array(productCartItemSchema).min(1, \"At least one product is required\"),\r\n    customer: customerSchema,\r\n    billing_address: billingAddressSchema,\r\n    return_url: z.string().url(\"Return URL must be a valid URL\"),\r\n    customMetadata: z.record(z.string(), z.string()).optional(),\r\n});\r\n\r\nexport async function POST(request: Request) {\r\n    try {\r\n        const body = await request.json();\r\n\r\n        const validationResult = checkoutSessionSchema.safeParse(body);\r\n        if (!validationResult.success) {\r\n            return NextResponse.json(\r\n                {\r\n                    error: \"Validation failed\",\r\n                    details: validationResult.error.issues.map(issue => ({\r\n                        field: issue.path.join('.'),\r\n                        message: issue.message\r\n                    }))\r\n                },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        const { productCart, customer, billing_address, return_url, customMetadata } = validationResult.data;\r\n\r\n        const session = await getDodoPaymentsClient().checkoutSessions.create({\r\n            product_cart: productCart,\r\n            customer: customer,\r\n            billing_address: billing_address as DodoPayments.Payments.BillingAddress,\r\n            return_url: return_url,\r\n            metadata: customMetadata,\r\n        });\r\n\r\n        return NextResponse.json(session);\r\n    } catch (error) {\r\n        console.error('Error in checkout POST handler:', error);\r\n        return NextResponse.json(\r\n            { error: 'Internal server error' },\r\n            { status: 500 }\r\n        );\r\n    }\r\n}"
    },
    {
      "target": "app\\api\\(dodopayments)\\customer\\payments\\route.ts",
      "type": "template",
      "content": "import { getDodoPaymentsClient } from \"@/lib/dodopayments\";\r\nimport { NextResponse } from \"next/server\";\r\nimport { z } from \"zod\";\r\n\r\nconst paymentQuerySchema = z.object({\r\n    customer_id: z.string().min(1, \"Customer ID is required\"),\r\n});\r\n\r\nexport async function GET(request: Request) {\r\n    try {\r\n        const url = new URL(request.url);       \r\n        const customer_id = url.searchParams.get('customer_id');\r\n\r\n        const validationResult = paymentQuerySchema.safeParse({ customer_id });\r\n\r\n        if (!validationResult.success) {\r\n            return NextResponse.json(\r\n                { error: validationResult.error.issues[0].message },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        const validatedParams = validationResult.data;\r\n\r\n        const payments = await getDodoPaymentsClient().payments.list({\r\n            customer_id: validatedParams.customer_id,\r\n        });\r\n\r\n        return NextResponse.json(payments);\r\n    } catch (error) {\r\n        console.error('Error fetching customer payments:', error);\r\n        return NextResponse.json({ error: 'Failed to fetch customer payments' }, { status: 500 });\r\n    }\r\n}"
    },
    {
      "target": "app\\api\\(dodopayments)\\customer\\route.ts",
      "type": "template",
      "content": "import { getDodoPaymentsClient } from \"@/lib/dodopayments\";\r\nimport { NextResponse } from \"next/server\";\r\nimport { z } from \"zod\";\r\n\r\nconst customerIdSchema = z.object({\r\n    customer_id: z.string().min(1, \"Customer ID is required\"),\r\n});\r\n\r\nconst createCustomerSchema = z.object({\r\n    email: z.string().email(\"Invalid email format\"),\r\n    name: z.string().min(1, \"Name is required\"),\r\n    phone_number: z.string().optional().nullable(),\r\n});\r\n\r\nconst updateCustomerSchema = z.object({\r\n    name: z.string().optional().nullable(),\r\n    phone_number: z.string().optional().nullable(),\r\n});\r\n\r\nexport async function GET(request: Request) {\r\n    try {\r\n        const url = new URL(request.url);\r\n        const queryParams = {\r\n            customer_id: url.searchParams.get('customer_id'),\r\n        };\r\n        const validationResult = customerIdSchema.safeParse(queryParams);\r\n\r\n        if (!validationResult.success) {\r\n            return NextResponse.json(\r\n                { error: validationResult.error.issues[0].message },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        const { customer_id } = validationResult.data;\r\n        const customer = await getDodoPaymentsClient().customers.retrieve(customer_id);\r\n        return NextResponse.json(customer);\r\n    } catch (error) {\r\n        console.error('Error retrieving customer:', error);\r\n        return NextResponse.json(\r\n            { error: 'Failed to retrieve customer' },\r\n            { status: 500 }\r\n        );\r\n    }\r\n}\r\n\r\nexport async function POST(request: Request) {\r\n    try {\r\n        const body = await request.json();\r\n\r\n        const validationResult = createCustomerSchema.safeParse(body);\r\n        if (!validationResult.success) {\r\n            return NextResponse.json(\r\n                { error: validationResult.error.issues[0].message },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        const customer = await getDodoPaymentsClient().customers.create(validationResult.data);\r\n        return NextResponse.json(customer);\r\n    } catch (error) {\r\n        console.error('Error creating customer:', error);\r\n        return NextResponse.json(\r\n            { error: 'Failed to create customer' },\r\n            { status: 500 }\r\n        );\r\n    }\r\n}\r\n\r\nexport async function PUT(request: Request) {\r\n    try {\r\n        const url = new URL(request.url);\r\n        const customer_id = url.searchParams.get('customer_id');\r\n        const body = await request.json();\r\n\r\n        const customerIdValidation = customerIdSchema.safeParse({ customer_id });\r\n        if (!customerIdValidation.success) {\r\n            return NextResponse.json(\r\n                { error: customerIdValidation.error.issues[0].message },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        const updateValidation = updateCustomerSchema.safeParse(body);\r\n        if (!updateValidation.success) {\r\n            return NextResponse.json(\r\n                { error: updateValidation.error.issues[0].message },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        const { customer_id: validCustomerId } = customerIdValidation.data;\r\n        const customer = await getDodoPaymentsClient().customers.update(validCustomerId, updateValidation.data);\r\n        return NextResponse.json(customer);\r\n    } catch (error) {\r\n        console.error('Error updating customer:', error);\r\n        return NextResponse.json(\r\n            { error: 'Failed to update customer' },\r\n            { status: 500 }\r\n        );\r\n    }\r\n}"
    },
    {
      "target": "app\\api\\(dodopayments)\\customer\\subscriptions\\route.ts",
      "type": "template",
      "content": "import { getDodoPaymentsClient } from \"@/lib/dodopayments\";\r\nimport { NextResponse } from \"next/server\";\r\nimport { z } from \"zod\";\r\n\r\nconst subscriptionQuerySchema = z.object({\r\n    customer_id: z.string().min(1, \"Customer ID is required\"),\r\n});\r\n\r\nexport async function GET(request: Request) {\r\n    try {\r\n        const url = new URL(request.url);\r\n        const customer_id = url.searchParams.get('customer_id');\r\n\r\n        const validationResult = subscriptionQuerySchema.safeParse({ customer_id });\r\n\r\n        if (!validationResult.success) {\r\n            return NextResponse.json(\r\n                { error: validationResult.error.issues[0].message },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        const subscriptions = await getDodoPaymentsClient().subscriptions.list({\r\n            customer_id: validationResult.data.customer_id,\r\n        });\r\n\r\n        return NextResponse.json(subscriptions);\r\n    } catch (error) {\r\n        console.error('Error fetching subscriptions:', error);\r\n        return NextResponse.json({ error: 'Failed to fetch subscriptions' }, { status: 500 });\r\n    }\r\n}"
    },
    {
      "target": "app\\api\\(dodopayments)\\product\\route.ts",
      "type": "template",
      "content": "import { getDodoPaymentsClient } from \"@/lib/dodopayments\";\r\nimport { NextResponse } from \"next/server\";\r\nimport { z } from \"zod\";\r\n\r\nconst productIdSchema = z.object({\r\n    product_id: z.string().min(1, \"Product ID is required\"),\r\n});\r\n\r\nexport async function GET(request: Request) {\r\n    try {\r\n        const url = new URL(request.url);\r\n        const queryParams = {\r\n            product_id: url.searchParams.get('product_id'),\r\n        };\r\n        const validationResult = productIdSchema.safeParse(queryParams);\r\n\r\n        if (!validationResult.success) {\r\n            return NextResponse.json(\r\n                { error: validationResult.error.issues[0].message },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        const { product_id } = validationResult.data;\r\n\r\n        const product = await getDodoPaymentsClient().products.retrieve(product_id);\r\n        return NextResponse.json(product);\r\n    } catch (error) {\r\n        console.error('Error retrieving product:', error);\r\n        return NextResponse.json(\r\n            { error: 'Failed to retrieve product' },\r\n            { status: 500 }\r\n        );\r\n    }\r\n}"
    },
    {
      "target": "app\\api\\(dodopayments)\\products\\route.ts",
      "type": "template",
      "content": "import { getDodoPaymentsClient } from \"@/lib/dodopayments\";\r\nimport { NextResponse } from \"next/server\";\r\n\r\nexport async function GET() {\r\n    try {\r\n        const products = await getDodoPaymentsClient().products.list();\r\n        return NextResponse.json(products.items);\r\n    } catch (error) {\r\n        console.error('Error fetching products:', error);\r\n        return NextResponse.json(\r\n            { error: \"Failed to fetch products\" },\r\n            { status: 500 }\r\n        );\r\n    }\r\n}"
    },
    {
      "target": "app\\api\\(dodopayments)\\webhook\\route.ts",
      "type": "template",
      "content": "import { Webhook } from \"standardwebhooks\";\r\nimport { headers } from \"next/headers\";\r\nimport { getDodoPaymentsClient } from \"@/lib/dodopayments\";\r\n\r\nconst webhook = new Webhook(process.env.DODO_PAYMENTS_WEBHOOK_KEY!);\r\n\r\nexport async function POST(request: Request) {\r\n  const headersList =  await headers();\r\n  try {\r\n    const rawBody = await request.text();\r\n    const webhookHeaders = {\r\n      \"webhook-id\": headersList.get(\"webhook-id\") || \"\",\r\n      \"webhook-signature\": headersList.get(\"webhook-signature\") || \"\",\r\n      \"webhook-timestamp\": headersList.get(\"webhook-timestamp\") || \"\",\r\n    };\r\n    await webhook.verify(rawBody, webhookHeaders);\r\n    const payload = JSON.parse(rawBody);\r\n\r\n    if (payload.data.payload_type === \"Subscription\") {\r\n      switch (payload.type) {\r\n        case \"subscription.active\":\r\n          const subscription = await getDodoPaymentsClient().subscriptions.retrieve(payload.data.subscription_id);\r\n          console.log(\"-------SUBSCRIPTION DATA START ---------\")\r\n          console.log(subscription)\r\n          console.log(\"-------SUBSCRIPTION DATA END ---------\")\r\n          break;\r\n        case \"subscription.failed\":\r\n          break;\r\n        case \"subscription.cancelled\":\r\n          break;\r\n        case \"subscription.renewed\":\r\n          break;\r\n        case \"subscription.on_hold\":\r\n          break\r\n        default:\r\n          break;\r\n      }\r\n    } else if (payload.data.payload_type === \"Payment\") {\r\n        switch (payload.type) {\r\n            case \"payment.succeeded\":\r\n              const paymentDataResp = await getDodoPaymentsClient().payments.retrieve(payload.data.payment_id)\r\n              console.log(\"-------PAYMENT DATA START ---------\")\r\n              console.log(paymentDataResp)\r\n              console.log(\"-------PAYMENT DATA END ---------\")\r\n              break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n    return Response.json(\r\n      { message: \"Webhook processed successfully\" },\r\n      { status: 200 }\r\n    );\r\n  } catch (error) {\r\n    console.log(\" ----- webhoook verification failed -----\")\r\n    console.log(error)\r\n    return Response.json(\r\n      { message: \"Webhook processed successfully\" },\r\n      { status: 200 }\r\n    );\r\n  }\r\n}"
    },
    {
      "target": ".env.example",
      "type": "template",
      "content": "DODO_PAYMENTS_API_KEY=your-api-key\r\nDODO_PAYMENTS_WEBHOOK_KEY=your-webhook-secret\r\nDODO_PAYMENTS_RETURN_URL=https://yourdomain.com/checkout/success\r\nDODO_PAYMENTS_ENVIRONMENT=\"test\"or\"live\""
    }
  ],
  "dependencies": [
    "dodopayments",
    "standardwebhooks",
    "zod"
  ]
}