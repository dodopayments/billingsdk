{
  "name": "express-dodopayments",
  "description": "DodoPayments template for Express.js",
  "framework": "express",
  "files": [
    {
      "target": "src/lib/dodopayments.ts",
      "type": "template",
      "content": "import { DodoPayments } from 'dodopayments'\nimport { Request, Response, NextFunction } from 'express'\nimport { z } from 'zod'\n\ntype Product = DodoPayments.Product\n\nlet dodopaymentsClient: DodoPayments | null = null\n\nexport function getDodoPaymentsClient(): DodoPayments {\n  if (!dodopaymentsClient) {\n    // Load environment variables from .env if available\n    try { require('dotenv').config(); } catch (_) {}\n    const token = process.env.DODO_PAYMENTS_API_KEY\n    const environment = process.env.DODO_PAYMENTS_ENVIRONMENT as \"live_mode\" | \"test_mode\"\n\n    if (process.env.NODE_ENV !== 'production') {\n      const maskedToken = token ? `${token.slice(0, 4)}...${token.slice(-4)}` : 'missing'\n      console.debug('Initializing DodoPayments client...')\n      console.debug('Token present:', !!token ? maskedToken : 'missing')\n      console.debug('Environment:', environment)\n    }\n\n    if (!token) {\n      const baseMsg = 'DODO_PAYMENTS_API_KEY is missing'\n      const devTips = `\\nPlease check:\\n1. Your .env file exists in the project root\\n2. The file contains: DODO_PAYMENTS_API_KEY=<your-api-key>\\n3. You've restarted your development server\\n4. No extra quotes or spaces in the .env file\\n`\n      throw new Error(process.env.NODE_ENV === 'production' ? baseMsg : baseMsg + devTips)\n    }\n\n    if (!environment || (environment !== \"live_mode\" && environment !== \"test_mode\")) {\n      throw new Error('DODO_PAYMENTS_ENVIRONMENT must be either \"live_mode\" or \"test_mode\"')\n    }\n\n    dodopaymentsClient = new DodoPayments({\n      bearerToken: token,\n      environment: environment,\n    })\n  }\n\n  return dodopaymentsClient\n}\n\nexport function validateRequest(schema: z.ZodSchema) {\n  return (req: Request, res: Response, next: NextFunction) => {\n    const result = schema.safeParse(req.body)\n    if (!result.success) {\n      return res.status(400).json({\n        error: \"Validation failed\",\n        details: result.error.issues.map(issue => ({\n          field: issue.path.join('.'),\n          message: issue.message\n        }))\n      })\n    }\n    req.body = result.data\n    next()\n  }\n}\n\nexport function validateQuery(schema: z.ZodSchema) {\n  return (req: Request, res: Response, next: NextFunction) => {\n    const result = schema.safeParse(req.query)\n    if (!result.success) {\n      return res.status(400).json({\n        error: \"Query validation failed\",\n        details: result.error.issues.map(issue => ({\n          field: issue.path.join('.'),\n          message: issue.message\n        }))\n      })\n    }\n    req.query = result.data\n    next()\n  }\n}\n\nexport function handleDodoPaymentsError(\n  error: any,\n  _req: Request,\n  res: Response,\n  _next: NextFunction\n) {\n  console.error('DodoPayments API Error:', error)\n\n  if (error.status) {\n    return res.status(error.status).json({\n      error: error.message || 'API Error'\n    })\n  }\n\n  res.status(500).json({\n    error: 'Internal server error'\n  })\n}\n\nexport const createCheckoutSession = async (\n  productCart: Array<{ product_id: string; quantity: number; amount?: number }>,\n  customer: DodoPayments.Payments.CustomerRequest,\n  billing_address: DodoPayments.Payments.BillingAddress,\n  return_url: string,\n  customMetadata?: Record<string, string>\n) => {\n  try {\n    const session = await getDodoPaymentsClient().checkoutSessions.create({\n      product_cart: productCart,\n      customer: customer,\n      billing_address: billing_address,\n      return_url: return_url,\n      metadata: customMetadata,\n    })\n    return session\n  } catch (error) {\n    console.error('Error creating checkout session:', error)\n    throw error\n  }\n}\n\nexport const retrieveCustomer = async (customer_id: string): Promise<DodoPayments.Customers.Customer> => {\n  try {\n    const customer = await getDodoPaymentsClient().customers.retrieve(customer_id)\n    return customer\n  } catch (error) {\n    console.error('Error retrieving customer:', error)\n    throw error\n  }\n}\n\nexport const createCustomer = async (customer: DodoPayments.Customers.CustomerCreateParams): Promise<DodoPayments.Customers.Customer> => {\n  try {\n    const newCustomer = await getDodoPaymentsClient().customers.create(customer)\n    return newCustomer\n  } catch (error) {\n    console.error('Error creating customer:', error)\n    throw error\n  }\n}\n\nexport const updateCustomer = async (\n  customer_id: string,\n  customer: DodoPayments.Customers.CustomerUpdateParams\n): Promise<DodoPayments.Customers.Customer> => {\n  try {\n    const updatedCustomer = await getDodoPaymentsClient().customers.update(customer_id, customer)\n    return updatedCustomer\n  } catch (error) {\n    console.error('Error updating customer:', error)\n    throw error\n  }\n}\n\nexport const listProducts = async () => {\n  try {\n    const products = await getDodoPaymentsClient().products.list()\n    return products.items\n  } catch (error) {\n    console.error('Error listing products:', error)\n    throw error\n  }\n}\n\nexport const retrieveProduct = async (product_id: string): Promise<Product> => {\n  try {\n    const product = await getDodoPaymentsClient().products.retrieve(product_id)\n    return product\n  } catch (error) {\n    console.error('Error retrieving product:', error)\n    throw error\n  }\n}\n\nexport const listCustomerSubscriptions = async (customer_id: string): Promise<DodoPayments.Subscriptions.SubscriptionListResponse[]> => {\n  try {\n    const subscriptions = await getDodoPaymentsClient().subscriptions.list({\n      customer_id: customer_id,\n    })\n    return subscriptions.items || []\n  } catch (error) {\n    console.error('Error listing customer subscriptions:', error)\n    throw error\n  }\n}\n\nexport const listCustomerPayments = async (customer_id: string): Promise<DodoPayments.Payments.PaymentListResponse[]> => {\n  try {\n    const payments = await getDodoPaymentsClient().payments.list({\n      customer_id: customer_id,\n    })\n    return payments.items || []\n  } catch (error) {\n    console.error('Error listing customer payments:', error)\n    throw error\n  }\n}\n\nexport const asyncHandler = (fn: Function) => {\n  return (req: Request, res: Response, next: NextFunction) => {\n    Promise.resolve(fn(req, res, next)).catch(next)\n  }\n}\n"
    },
    {
      "target": "src/routes/dodopayments/route.ts",
      "type": "template",
      "content": "import express from 'express';\nimport cors from 'cors';\nimport { handleDodoPaymentsError } from '../../lib/dodopayments';\n\nimport checkoutRouter from './checkout';\nimport customerRouter from './customer';\nimport productsRouter from './products';\nimport productRouter from './product';\nimport webhookRouter from './webhook';\nimport paymentsRouter from './payments';\nimport subscriptionsRouter from './subscriptions';\n\nconst router = express.Router();\n\nconst allowedOrigins = (process.env.ALLOWED_ORIGINS || '')\n  .split(',')\n  .map(o => o.trim())\n  .filter(o => o.length > 0);\n\nrouter.use(cors({\n  origin: (origin, callback) => {\n    if (!origin) return callback(new Error('Origin header required'));\n    if (allowedOrigins.length === 0) return callback(new Error('CORS not configured'));\n    if (allowedOrigins.includes(origin)) return callback(null, true);\n    return callback(new Error('Not allowed by CORS'));\n  },\n  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],\n  allowedHeaders: ['Content-Type', 'Authorization', 'webhook-id', 'webhook-signature', 'webhook-timestamp'],\n  credentials: true\n}));\n\nrouter.options('*', cors({\n  origin: (origin, callback) => {\n    if (!origin) return callback(new Error('Origin header required'));\n    if (allowedOrigins.length === 0) return callback(new Error('CORS not configured'));\n    if (allowedOrigins.includes(origin)) return callback(null, true);\n    return callback(new Error('Not allowed by CORS'));\n  },\n  credentials: true\n}));\n\n// Important: mount webhook BEFORE json parser to keep raw body intact\nrouter.use('/webhook', webhookRouter);\n\nrouter.use(express.json({\n  limit: '10mb',\n  verify: (req: any, res, buf) => {\n    if (req.originalUrl?.includes('/webhook')) {\n      (req as any).rawBody = buf;\n    }\n  }\n}));\n\nrouter.get('/health', (req, res) => {\n  res.json({ \n    status: 'ok', \n    service: 'dodopayments-api',\n    timestamp: new Date().toISOString()\n  });\n});\n\nrouter.use('/checkout', checkoutRouter);\nrouter.use('/customer', customerRouter);\nrouter.use('/products', productsRouter);\nrouter.use('/product', productRouter);\nrouter.use('/payments', paymentsRouter);\nrouter.use('/subscriptions', subscriptionsRouter);\n\nrouter.use(handleDodoPaymentsError);\n\nexport default router;\n\n\n"
    },
    {
      "target": "src/routes/dodopayments/checkout.ts",
      "type": "template",
      "content": "import express from 'express';\nimport { z } from 'zod';\nimport { validateRequest, createCheckoutSession } from '../../lib/dodopayments';\nimport { DodoPayments } from 'dodopayments';\n\nconst router = express.Router();\n\nconst productCartItemSchema = z.object({\n  product_id: z.string().min(1, \"Product ID is required\"),\n  quantity: z.number().int().min(1, \"Quantity must be at least 1\"),\n  amount: z.number().int().min(0).optional(),\n});\n\nconst attachExistingCustomerSchema = z.object({\n  customer_id: z.string().min(1, \"Customer ID is required\"),\n});\n\nconst newCustomerSchema = z.object({\n  email: z.string().email(\"Invalid email format\"),\n  name: z.string().min(1, \"Name is required\"),\n  phone_number: z.string().optional().nullable(),\n  create_new_customer: z.boolean().optional(),\n});\n\nconst customerSchema = z.union([attachExistingCustomerSchema, newCustomerSchema]);\n\nconst billingAddressSchema = z.object({\n  city: z.string().min(1, \"City is required\"),\n  country: z.string().regex(/^[A-Z]{2}$/, \"Country must be a 2-letter uppercase ISO code\"),\n  state: z.string().min(1, \"State is required\"),\n  street: z.string().min(1, \"Street address is required\"),\n  zipcode: z.string().min(1, \"Zipcode is required\"),\n});\n\nconst checkoutSessionSchema = z.object({\n  productCart: z.array(productCartItemSchema).min(1, \"At least one product is required\"),\n  customer: customerSchema,\n  billing_address: billingAddressSchema,\n  return_url: z.string().url(\"Return URL must be a valid URL\"),\n  customMetadata: z.record(z.string(), z.string()).optional(),\n});\n\nrouter.post('/', validateRequest(checkoutSessionSchema), async (req, res, next) => {\n  try {\n    const { productCart, customer, billing_address, return_url, customMetadata } = req.body;\n\n    const session = await createCheckoutSession(\n      productCart,\n      customer as DodoPayments.Payments.CustomerRequest,\n      billing_address as DodoPayments.Payments.BillingAddress,\n      return_url,\n      customMetadata\n    );\n\n    res.json(session);\n  } catch (error) {\n    next(error);\n  }\n});\n\nexport default router;\n"
    },
    {
      "target": "src/routes/dodopayments/customer.ts",
      "type": "template",
      "content": "import express from 'express';\nimport { z } from 'zod';\nimport { \n  validateRequest, \n  validateQuery, \n  retrieveCustomer, \n  createCustomer, \n  updateCustomer \n} from '../../lib/dodopayments';\n\nconst router = express.Router();\n\nconst customerIdSchema = z.object({\n  customer_id: z.string().min(1, \"Customer ID is required\"),\n});\n\nconst createCustomerSchema = z.object({\n  email: z.string().email(\"Invalid email format\"),\n  name: z.string().min(1, \"Name is required\"),\n  phone_number: z.string().optional().nullable(),\n});\n\nconst updateCustomerSchema = z.object({\n  name: z.string().optional().nullable(),\n  phone_number: z.string().optional().nullable(),\n}).refine((data) => data.name !== undefined || data.phone_number !== undefined, {\n  message: 'At least one field must be provided for update',\n  path: ['name'],\n});\n\nrouter.get('/', validateQuery(customerIdSchema), async (req, res, next) => {\n  try {\n    const { customer_id } = req.query as { customer_id: string };\n    const customer = await retrieveCustomer(customer_id);\n    if (!customer) {\n      return res.status(404).json({ error: 'Customer not found' });\n    }\n    res.json(customer);\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.post('/', validateRequest(createCustomerSchema), async (req, res, next) => {\n  try {\n    const customer = await createCustomer(req.body);\n    res.status(201).json(customer);\n  } catch (error) {\n    next(error);\n  }\n});\n\nrouter.put('/', validateQuery(customerIdSchema), validateRequest(updateCustomerSchema), async (req, res, next) => {\n  try {\n    const { customer_id } = req.query as { customer_id: string };\n    const customer = await updateCustomer(customer_id, req.body);\n    if (!customer) {\n      return res.status(404).json({ error: 'Customer not found' });\n    }\n    res.json(customer);\n  } catch (error) {\n    next(error);\n  }\n});\n\nexport default router;\n"
    },
    {
      "target": "src/routes/dodopayments/products.ts",
      "type": "template",
      "content": "import express from 'express';\nimport { listProducts } from '../../lib/dodopayments';\n\nconst router = express.Router();\n\nrouter.get('/', async (req, res, next) => {\n  try {\n    const products = await listProducts();\n    res.json(products);\n  } catch (error) {\n    next(error);\n  }\n});\n\nexport default router;\n"
    },
    {
      "target": "src/routes/dodopayments/product.ts",
      "type": "template",
      "content": "import express from 'express';\nimport { z } from 'zod';\nimport { validateQuery, retrieveProduct } from '../../lib/dodopayments';\n\nconst router = express.Router();\n\nconst productIdSchema = z.object({\n  product_id: z.string().min(1, \"Product ID is required\"),\n});\n\nrouter.get('/', validateQuery(productIdSchema), async (req, res, next) => {\n  try {\n    const { product_id } = req.query as { product_id: string };\n    const product = await retrieveProduct(product_id);\n    res.json(product);\n  } catch (error) {\n    next(error);\n  }\n});\n\nexport default router;\n"
    },
    {
      "target": "src/routes/dodopayments/subscriptions.ts",
      "type": "template",
      "content": "import express from 'express';\nimport { z } from 'zod';\nimport { validateQuery, listCustomerSubscriptions } from '../../lib/dodopayments';\n\nconst router = express.Router();\n\nconst subscriptionQuerySchema = z.object({\n  customer_id: z.string().min(1, \"Customer ID is required\"),\n});\n\nrouter.get('/', validateQuery(subscriptionQuerySchema), async (req, res, next) => {\n  try {\n    const { customer_id } = req.query as { customer_id: string };\n    const authCustomerId = (req as any).user?.id ?? (req as any).auth?.userId;\n    const isAdmin = (req as any).user?.roles?.includes?.('admin');\n    if (!isAdmin && authCustomerId && authCustomerId !== customer_id) {\n      return res.status(403).json({ error: 'Forbidden: mismatched customer_id' });\n    }\n    const subscriptions = await listCustomerSubscriptions(customer_id);\n    res.json(subscriptions);\n  } catch (error) {\n    next(error);\n  }\n});\n\nexport default router;\n"
    },
    {
      "target": "src/routes/dodopayments/payments.ts",
      "type": "template",
      "content": "import express from 'express';\nimport { z } from 'zod';\nimport { validateQuery, listCustomerPayments } from '../../lib/dodopayments';\n\nconst router = express.Router();\n\nconst paymentQuerySchema = z.object({\n  customer_id: z.string().min(1, \"Customer ID is required\"),\n});\n\nrouter.get('/', validateQuery(paymentQuerySchema), async (req, res, next) => {\n  try {\n    const { customer_id } = req.query as { customer_id: string };\n    const payments = await listCustomerPayments(customer_id);\n    res.json(payments);\n  } catch (error) {\n    next(error);\n  }\n});\n\nexport default router;\n"
    },
    {
      "target": "src/routes/dodopayments/webhook.ts",
      "type": "template",
      "content": "import express from 'express'\nimport { Webhook } from 'standardwebhooks'\nimport { getDodoPaymentsClient } from '../../lib/dodopayments'\n\nconst router = express.Router()\nconst webhookSecret = process.env.DODO_PAYMENTS_WEBHOOK_SECRET\nif (!webhookSecret) {\n  throw new Error('DODO_PAYMENTS_WEBHOOK_SECRET is missing')\n}\nconst webhook = new Webhook(webhookSecret)\n\nrouter.use(express.raw({ type: 'application/json', limit: '100kb' }))\n\nrouter.post('/', async (req, res) => {\n  try {\n    const rawBody = Buffer.isBuffer(req.body) ? req.body.toString() : ''\n    const getHeader = (value: string | string[] | undefined) => Array.isArray(value) ? value[0] : value\n    const webhookHeaders = {\n      'webhook-id': getHeader(req.headers['webhook-id']) || '',\n      'webhook-signature': getHeader(req.headers['webhook-signature']) || '',\n      'webhook-timestamp': getHeader(req.headers['webhook-timestamp']) || '',\n    }\n\n    if (!webhookHeaders['webhook-id'] || !webhookHeaders['webhook-signature'] || !webhookHeaders['webhook-timestamp']) {\n      return res.status(400).json({ error: 'Missing required webhook headers' })\n    }\n\n    try {\n      await webhook.verify(rawBody, webhookHeaders)\n    } catch (e) {\n      console.error('Webhook verification failed', { error: (e as Error)?.message })\n      return res.status(400).json({ error: 'Invalid webhook signature' })\n    }\n\n    let payload: any\n    try {\n      payload = JSON.parse(rawBody)\n    } catch (_e) {\n      return res.status(400).json({ error: 'Invalid JSON payload' })\n    }\n\n    if (payload.data.payload_type === \"Subscription\") {\n      switch (payload.type) {\n        case \"subscription.active\":\n          const subscription = await getDodoPaymentsClient().subscriptions.retrieve(payload.data.subscription_id)\n          const s: any = subscription as any\n          console.log('subscription.active', {\n            id: s.id,\n            status: s.status,\n            customer_id: s.customer_id,\n            plan_id: s.plan_id,\n          })\n          break\n        case \"subscription.failed\":\n          break\n        case \"subscription.cancelled\":\n          break\n        case \"subscription.renewed\":\n          break\n        case \"subscription.on_hold\":\n          break\n        default:\n          break\n      }\n    } else if (payload.data.payload_type === \"Payment\") {\n      switch (payload.type) {\n        case \"payment.succeeded\":\n          const paymentDataResp = await getDodoPaymentsClient().payments.retrieve(payload.data.payment_id)\n          const p: any = paymentDataResp as any\n          console.log('payment.succeeded', {\n            id: p.id,\n            status: p.status,\n            amount: p.amount,\n            currency: p.currency,\n            customer_id: p.customer_id,\n          })\n          break\n        default:\n          break\n      }\n    }\n\n    res.json({ message: 'Webhook processed successfully' })\n  } catch (error) {\n    console.error('Webhook handler error', { error: (error as Error)?.message })\n    res.status(500).json({ error: 'Internal server error' })\n  }\n})\n\nexport default router\n"
    },
    {
      "target": ".env.example",
      "type": "template",
      "content": "# DodoPayments Configuration\n# Get your API key from https://dashboard.dodopayments.com/\nDODO_PAYMENTS_API_KEY=your-api-key\nDODO_PAYMENTS_WEBHOOK_KEY=your-webhook-secret\nDODO_PAYMENTS_RETURN_URL=https://yourdomain.com/checkout/success\nDODO_PAYMENTS_ENVIRONMENT=test_mode\n\n# Optional: Allowed origins for CORS (comma-separated)\n# Leave empty or set to * to allow all origins\nALLOWED_ORIGINS=http://localhost:3000,https://yourdomain.com\n\n# Optional: Server port\nPORT=3000\n"
    }
  ],
  "dependencies": [
    "express",
    "@types/express",
    "dodopayments",
    "standardwebhooks",
    "zod",
    "cors",
    "@types/cors",
    "dotenv"
  ]
}