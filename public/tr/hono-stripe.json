{
  "name": "hono-stripe",
  "description": "Stripe template for Hono",
  "framework": "hono",
  "files": [
    {
      "target": "lib/stripe.ts",
      "type": "template",
      "content": "import Stripe from 'stripe';\n\nlet _stripe: Stripe | null = null;\nexport const getStripe = (): Stripe => {\n  const key = process.env.STRIPE_SECRET_KEY;\n  if (!key) {\n    throw new Error(\"STRIPE_SECRET_KEY is not set\")\n  }\n  if (!_stripe) {\n    _stripe = new Stripe(process.env.STRIPE_SECRET_KEY as string, {\n\n    });\n  }\n  return _stripe;\n};\n\nexport type Product = Stripe.Product;\nexport type Customer = Stripe.Customer;\nexport type Subscription = Stripe.Subscription;\nexport type PaymentIntent = Stripe.PaymentIntent;\n\n\nexport async function getProducts(): Promise<Product[]> {\n  try {\n    const stripe = getStripe();\n    const { data } = await stripe.products.list({ limit: 100 });\n    return data;\n  } catch (error) {\n    console.error('Error fetching products', error);\n    throw new Error('Failed to fetch products');\n  }\n}\n\nexport async function getProduct(product_id: string): Promise<Product> {\n  try {\n    const stripe = getStripe();\n    return await stripe.products.retrieve(product_id);\n  } catch (error) {\n    console.error('Error fetching product', error);\n    throw new Error('Failed to fetch product');\n  }\n}\n\n\nexport async function getCustomer(customer_id: string): Promise<Customer | Stripe.DeletedCustomer> {\n  try {\n    const stripe = getStripe();\n    const customer = await stripe.customers.retrieve(customer_id);\n\n    if ((customer as Stripe.DeletedCustomer).deleted) {\n      return customer as Stripe.DeletedCustomer;\n    }\n    return customer as Customer;\n  } catch (error) {\n    console.error('Error fetching customer', error);\n    throw new Error('Failed to fetch customer');\n  }\n}\n\nexport async function createCustomer(params: Stripe.CustomerCreateParams): Promise<Customer> {\n  try {\n    const stripe = getStripe();\n    return await stripe.customers.create(params);\n  } catch (error) {\n    console.error('Error creating customer', error);\n    throw new Error('Failed to create customer');\n  }\n}\n\nexport async function updateCustomer(customer_id: string, params: Stripe.CustomerUpdateParams): Promise<Customer> {\n  try {\n    const stripe = getStripe();\n    return await stripe.customers.update(customer_id, params);\n  } catch (error) {\n    console.error('Error updating customer', error);\n    throw new Error('Failed to update customer');\n  }\n}\n\n\nexport async function getCustomerSubscriptions(customer_id: string): Promise<Subscription[]> {\n  try {\n    const stripe = getStripe();\n    const { data } = await stripe.subscriptions.list({ customer: customer_id });\n    return data;\n  } catch (error) {\n    console.error('Error fetching subscriptions', error);\n    throw new Error('Failed to fetch subscriptions');\n  }\n}\n\n\nexport async function getCustomerPayments(customer_id: string): Promise<PaymentIntent[]> {\n  try {\n    const stripe = getStripe();\n    const { data } = await stripe.paymentIntents.list({ customer: customer_id, limit: 100 });\n    return data;\n  } catch (error) {\n    console.error('Error fetching payments', error);\n    throw new Error('Failed to fetch payments');\n  }\n}\n\n\nexport async function checkout(opts: {\n  price_id: string;\n  customer_id?: string;\n  success_url: string;\n  cancel_url: string;\n}): Promise<{ checkout_url: string }> {\n  try {\n    const stripe = getStripe();\n    const session = await stripe.checkout.sessions.create({\n      mode: 'subscription',\n      line_items: [{ price: opts.price_id, quantity: 1 }],\n      customer: opts.customer_id ?? '',\n      success_url: opts.success_url,\n      cancel_url: opts.cancel_url,\n    });\n    return { checkout_url: session.url! };\n  } catch (error) {\n    console.error('Error creating checkout session', error);\n    throw new Error('Failed to create checkout session');\n  }\n}\n\n"
    },
    {
      "target": "routes/route.ts",
      "type": "template",
      "content": "import { Hono } from 'hono';\nimport { checkoutRouter } from './checkout';\nimport { customerRouter } from './customer';\nimport { paymentsRouter } from './payments';\nimport { productsRouter } from './products';\nimport { subscriptionsRouter } from './subscriptions';\nimport { webhookRouter } from './webhook';\n\nconst router = new Hono()\n  .route('/checkout', checkoutRouter)\n  .route('/customer', customerRouter)\n  .route('/payments', paymentsRouter)\n  .route('/products', productsRouter)\n  .route('/subscriptions', subscriptionsRouter)\n  .route('/webhook', webhookRouter);\n\n\nexport { router as stripeRouter };\n"
    },
    {
      "target": "routes/stripe/checkout.ts",
      "type": "template",
      "content": "import { z } from 'zod';\nimport { Hono } from 'hono';\nimport type Stripe from 'stripe';\nimport { getStripe } from '../../lib/stripe';\nimport { zValidator } from '@hono/zod-validator';\n\nconst stripe = getStripe();\n\nconst productCartItemSchema = z.object({\n  price_id: z.string().min(1, \"Price ID is required\"),\n  quantity: z.number().int().min(1, \"Quantity must be at least 1\"),\n});\n\nconst attachExistingCustomerSchema = z.object({\n  customer_id: z.string().min(1, \"Customer ID is required\"),\n});\n\nconst newCustomerSchema = z.object({\n  email: z.email(\"Invalid email format\"),\n  name: z.string().min(1, \"Name is required\"),\n  phone_number: z.string().optional().nullable(),\n  create_new_customer: z.boolean().optional(),\n});\n\nconst customerSchema = z.union([attachExistingCustomerSchema, newCustomerSchema]);\n\nconst checkoutSessionSchema = z.object({\n  productCart: z.array(productCartItemSchema).min(1, \"At least one product is required\"),\n  customer: customerSchema.optional(),\n  success_url: z.url(\"Success URL must be a valid URL\"),\n  cancel_url: z.url(\"Cancel URL must be a valid URL\"),\n  metadata: z.record(z.string(), z.string()).optional(),\n});\n\nconst router = new Hono().post('/', zValidator('json', checkoutSessionSchema, (result, c) => {\n  if (!result.success) {\n    return c.json({\n      error: \"Validation failed\",\n      details: result.error.issues.map(issue => ({\n        field: issue.path.join('.'),\n        message: issue.message,\n      })),\n    }, 400)\n  }\n}), async (c) => {\n  try {\n    const { productCart, customer, success_url, cancel_url, metadata } = c.req.valid('json');\n    let customerId: string | undefined;\n\n    if (customer && 'email' in customer) {\n      const stripeCustomer = await stripe.customers.create({\n        email: customer.email ?? \"\",\n        name: customer.name ?? \"\",\n        phone: customer.phone_number ?? \"\",\n      });\n      customerId = stripeCustomer.id;\n    } else if (customer && 'customer_id' in customer) {\n      customerId = customer.customer_id;\n    }\n\n    const sessionParams: Stripe.Checkout.SessionCreateParams = {\n      payment_method_types: [\"card\"],\n      line_items: productCart.map(item => ({\n        price: item.price_id,\n        quantity: item.quantity,\n      })),\n      mode: \"payment\",\n      success_url: success_url + \"?session_id={CHECKOUT_SESSION_ID}\",\n      cancel_url: cancel_url,\n\n      ...(metadata ? { metadata } : {}),\n    };\n\n    if (customerId) {\n      sessionParams.customer = customerId;\n    }\n\n    const session = await stripe.checkout.sessions.create(sessionParams);\n\n    return c.json({ url: session.url });\n  } catch (error) {\n    console.error('Stripe checkout error:', error);\n    return c.json({ error: 'Internal server error' }, 500);\n  }\n})\n\nexport { router as checkoutRouter };\n"
    },
    {
      "target": "routes/stripe/customer.ts",
      "type": "template",
      "content": "import { getStripe } from '../../lib/stripe';\nimport { z } from 'zod';\nimport type Stripe from 'stripe';\nimport { Hono } from 'hono';\nimport { zValidator } from '@hono/zod-validator';\n\nconst stripe = getStripe();\n\nconst customerCreateSchema = z.object({\n  email: z.email(\"Invalid email format\"),\n  name: z.string().min(1, \"Name is required\"),\n  phone_number: z.string().optional().nullable(),\n});\n\nconst customerUpdateSchema = z.object({\n  email: z.email(\"Invalid email format\").optional(),\n  name: z.string().min(1, \"Name is required\").optional(),\n  phone_number: z.string().optional().nullable(),\n});\n\n\nconst router = new Hono()\n  .get('/:customer_id', zValidator('param', z.object({ customer_id: z.string() }), (result, c) => {\n    if (!result.success) {\n      return c.json({\n        error: \"customer_id parameter is required\",\n      }, 400)\n    }\n  }), async (c) => {\n    try {\n      const { customer_id } = c.req.valid('param');\n      const customer = await stripe.customers.retrieve(customer_id);\n      return c.json(customer);\n    } catch (error) {\n      console.error('Error fetching customer:', error);\n      return c.json({ error: 'Internal server error' }, 500);\n    }\n  })\n  .post('/',\n    zValidator('json', customerCreateSchema, (result, c) => {\n      if (!result.success) {\n        return c.json({\n          error: \"Validation failed\",\n          details: result.error.issues.map(issue => ({\n            field: issue.path.join('.'),\n            message: issue.message\n          }))\n        }, 400)\n      }\n    }),\n    async (c) => {\n      try {\n        const { email, name, phone_number } = c.req.valid('json');\n        const customer = await stripe.customers.create({\n          email: email,\n          name: name,\n          phone: phone_number ?? \"\",\n        });\n\n        return c.json(customer);\n      } catch (error) {\n        console.error('Error creating customer:', error);\n        return c.json({ error: 'Internal server error' }, 500);\n      }\n    })\n  .put('/:customer_id',\n    zValidator('param', z.object({ customer_id: z.string() }), (result, c) => {\n      if (!result.success) {\n        return c.json({\n          error: \"customer_id query parameter is required\",\n        }, 400)\n      }\n    }),\n    zValidator('json', customerUpdateSchema, (result, c) => {\n      if (!result.success) {\n        return c.json({\n          error: \"Validation failed\",\n          details: result.error.issues.map(issue => ({\n            field: issue.path.join('.'),\n            message: issue.message\n          }))\n        }, 400)\n      }\n    }),\n    async (c) => {\n      try {\n        const { customer_id } = c.req.valid('param');\n        const { email, name, phone_number } = c.req.valid('json');\n        const updateData: Stripe.CustomerUpdateParams = {};\n        if (email) updateData.email = email;\n        if (name) updateData.name = name;\n        if (phone_number) updateData.phone = phone_number;\n\n        const customer = await stripe.customers.update(customer_id, updateData);\n        return c.json(customer);\n      } catch (error) {\n        console.error('Error updating customer:', error);\n        return c.json({ error: 'Internal server error' }, 500);\n      }\n    })\n  .get('/subscriptions/:customer_id',\n    zValidator('param', z.object({ customer_id: z.string() }), (result, c) => {\n      if (!result.success) {\n        return c.json({\n          error: \"customer_id query parameter is required\",\n        }, 400)\n      }\n    }),\n    async (c) => {\n      try {\n        const { customer_id } = c.req.valid('param')\n        const subscriptions = await stripe.subscriptions.list({\n          customer: customer_id,\n          limit: 100,\n        });\n\n        return c.json(subscriptions.data);\n      } catch (error) {\n        console.error('Error fetching customer subscriptions:', error);\n        return c.json({ error: 'Internal server error' }, 500);\n      }\n    })\n  .get('/payments/:customer_id',\n    zValidator('param', z.object({ customer_id: z.string() }), (result, c) => {\n      if (!result.success) {\n        return c.json({\n          error: \"customer_id query parameter is required\",\n        }, 400)\n      }\n    }),\n    async (c) => {\n      try {\n        const { customer_id } = c.req.valid('param');\n        const paymentIntents = await stripe.paymentIntents.list({\n          customer: customer_id,\n          limit: 100,\n        });\n\n        return c.json(paymentIntents.data);\n      } catch (error) {\n        console.error('Error fetching customer payments:', error);\n        return c.json({ error: 'Internal server error' }, 500);\n      }\n    });\n\nexport { router as customerRouter };\n"
    },
    {
      "target": "routes/stripe/payments.ts",
      "type": "template",
      "content": "import { Hono } from 'hono';\nimport { zValidator } from '@hono/zod-validator';\nimport { z } from 'zod';\nimport { getStripe } from '../../lib/stripe';\nimport type { Stripe } from 'stripe';\n\nconst stripe = getStripe()\n\nconst router = new Hono()\n  .get('/:payment_id',\n    zValidator('param', z.object({\n      payment_id: z.string(),\n    }), (result, c) => {\n      if (!result.success) {\n        return c.json({\n          error: \"payment_id parameter is required\",\n        }, 400)\n      }\n    }\n    ),\n    async (c) => {\n      try {\n        const { payment_id } = c.req.valid('param');\n        const payment = await stripe.paymentIntents.retrieve(payment_id);\n        return c.json(payment);\n      } catch (error) {\n        console.error('Error fetching payment:', error);\n        return c.json({ error: 'Internal server error' }, 500);\n      }\n    })\n  .get('/list',\n    zValidator('query', z.object({\n      customer_id: z.string().optional(),\n      limit: z.coerce.number().optional(),\n      starting_after: z.string().optional(),\n    }), (result, c) => {\n      if (!result.success) {\n        return c.json({\n          error: \"Invalid query parameters\",\n          details: result.error.issues.map(issue => ({\n            field: issue.path.join('.'),\n            message: issue.message,\n          })),\n        }, 400)\n      }\n    }),\n    async (c) => {\n      try {\n        const { customer_id, limit, starting_after } = c.req.valid('query');\n\n        const params: Stripe.PaymentIntentListParams = {};\n\n        if (customer_id) {\n          params.customer = customer_id;\n        }\n        if (limit) {\n          params.limit = limit;\n        }\n        if (starting_after) {\n          params.starting_after = starting_after;\n        }\n\n        const payments = await stripe.paymentIntents.list(params);\n        return c.json(payments);\n      } catch (error) {\n        console.error('Error fetching payments list:', error);\n        return c.json({ error: 'Internal server error' }, 500);\n      }\n    });\n\nexport { router as paymentsRouter };\n"
    },
    {
      "target": "routes/stripe/products.ts",
      "type": "template",
      "content": "import { Hono } from 'hono';\nimport { getStripe } from '../../lib/stripe';\nimport { zValidator } from '@hono/zod-validator';\nimport { z } from 'zod';\n\nconst stripe = getStripe();\n\nconst router = new Hono()\n  .get('/',\n    zValidator('query', z.object({\n      limit: z.coerce.number().default(10).optional(),\n      starting_after: z.string().optional(),\n    }), (result, c) => {\n      if (!result.success) {\n        return c.json({\n          error: \"Invalid query parameters\",\n          details: result.error.issues.map(issue => ({\n            field: issue.path.join('.'),\n            message: issue.message,\n          })),\n        }, 400)\n      }\n    }),\n    async (c) => {\n      try {\n        const params = c.req.valid('query');\n        const products = await stripe.products.list(params);\n        return c.json(products.data); // this returns only product array\n      } catch (error) {\n        console.error('Error fetching products:', error);\n        return c.json({ error: 'Internal server error', details: (error as Error).message }, 500);\n      }\n    })\n  .get('/product/:product_id',\n    zValidator('param', z.object({\n      product_id: z.string(),\n    }), (result, c) => {\n      if (!result.success) {\n        return c.json({\n          error: \"product_id parameter is required\",\n        }, 400)\n      }\n    }),\n    async (c) => {\n      try {\n        const { product_id } = c.req.valid('param');\n        const product = await stripe.products.retrieve(product_id);\n        return c.json(product);\n      } catch (error) {\n        console.error('Error fetching product:', error);\n        return c.json({ error: 'Internal server error', details: (error as Error).message }, 500);\n      }\n    });\n\nexport { router as productsRouter };\n"
    },
    {
      "target": "routes/stripe/subscriptions.ts",
      "type": "template",
      "content": "import { Hono } from 'hono';\nimport type Stripe from 'stripe';\nimport { zValidator } from '@hono/zod-validator';\nimport { z } from 'zod';\nimport { getStripe } from '../../lib/stripe';\n\nconst stripe = getStripe();\n\nconst router = new Hono()\n  .get('/:subscription_id',\n    zValidator('param', z.object({\n      subscription_id: z.string(),\n    }), (result, c) => {\n      if (!result.success) {\n        return c.json({\n          error: \"subscription_id parameter is required\",\n        }, 400)\n      }\n    }),\n    async (c) => {\n      try {\n        const { subscription_id } = c.req.valid('param');\n\n        const subscription = await stripe.subscriptions.retrieve(subscription_id);\n        return c.json(subscription);\n      } catch (error) {\n        console.error('Error fetching subscription:', error);\n        return c.json({ error: 'Internal server error', details: (error as Error).message }, 500);\n      }\n    })\n  .get('/list',\n    zValidator('query', z.object({\n      customer_id: z.string(),\n      limit: z.coerce.number().optional().default(10),\n      starting_after: z.string().optional(),\n    }), (result, c) => {\n      if (!result.success) {\n        return c.json({\n          error: \"Invalid query parameters\",\n          details: result.error.issues.map(issue => ({\n            field: issue.path.join('.'),\n            message: issue.message,\n          })),\n        }, 400)\n      }\n    }),\n    async (c) => {\n      try {\n        const { customer_id, limit, starting_after } = c.req.valid('query');\n\n        const params: Stripe.SubscriptionListParams = {\n          customer: customer_id,\n          limit: limit,\n        };\n\n        if (starting_after) {\n          params.starting_after = starting_after;\n        }\n\n        const subscriptions = await stripe.subscriptions.list(params);\n        return c.json(subscriptions.data); // return only the subscriptions array\n      } catch (error) {\n        console.error('Error fetching subscriptions list:', error);\n        return c.json({ error: 'Internal server error', details: (error as Error).message }, 500);\n      }\n    });\n\nexport { router as subscriptionsRouter };\n\n"
    },
    {
      "target": "routes/stripe/webhook.ts",
      "type": "template",
      "content": "import { Hono } from 'hono';\nimport Stripe from 'stripe';\nimport { getStripe } from '../../lib/stripe';\n\nconst stripe = getStripe();\n\nconst router = new Hono()\n  .post('/', async (c) => {\n    const rawBody = await c.req.raw.text();\n    const sig = c.req.header('stripe-signature');\n\n    if (!sig) {\n      return c.json({ error: 'Missing Stripe signature' }, 400);\n    }\n\n    const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET!;\n    let event: Stripe.Event;\n\n    try {\n      event = stripe.webhooks.constructEvent(rawBody, sig, webhookSecret);\n    } catch (err) {\n      console.error('Webhook signature verification failed:', err);\n      return c.json({ error: 'Webhook verification failed' }, 400);\n    }\n\n    try {\n      switch (event.type) {\n        case 'customer.subscription.created':\n        case 'customer.subscription.updated':\n        case 'customer.subscription.deleted': {\n          const subscription = event.data.object as Stripe.Subscription;\n          console.log('Subscription event:', event.type, subscription.id);\n          break;\n        }\n        case 'payment_intent.succeeded': {\n          const paymentIntent = event.data.object as Stripe.PaymentIntent;\n          console.log('Payment succeeded:', paymentIntent.id, paymentIntent.amount);\n          break;\n        }\n        case 'payment_intent.payment_failed': {\n          const paymentIntent = event.data.object as Stripe.PaymentIntent;\n          console.log('Payment failed:', paymentIntent.id, paymentIntent.last_payment_error);\n          break;\n        }\n        case 'charge.refunded': {\n          const charge = event.data.object as Stripe.Charge;\n          console.log('Charge refunded:', charge.id, charge.amount_refunded);\n          break;\n        }\n        default:\n          console.log('Unhandled event type:', event.type);\n          break;\n      }\n\n      return c.json({ message: 'Webhook processed successfully' });\n    } catch (err) {\n      console.error('Error handling webhook event:', err);\n      return c.json({ error: 'Internal server error' }, 500);\n    }\n  });\n\nexport { router as webhookRouter };\n"
    },
    {
      "target": ".env.example",
      "type": "template",
      "content": "# DodoPayments Configurations\nDODO_PAYMENTS_API_KEY=your_api_key\nDODO_PAYMENTS_ENVIRONMENT=test_mode\nDODO_PAYMENTS_WEBHOOK_KEY=your_webhook_key_here\n\n# server configurations\nPORT=3000\nBUN_ENV=development\n\nSTRIPE_SECRET_KEY=sk_test_12345...\nSTRIPE_WEBHOOK_SECRET=whsec_12345\n"
    }
  ],
  "dependencies": [
    "stripe",
    "standardwebhooks",
    "zod",
    "hono",
    "@hono/zod-validator"
  ]
}