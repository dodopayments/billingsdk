{
  "name": "nextjs-stripe",
  "description": "Stripe template for NextJS",
  "framework": "nextjs",
  "files": [
    {
      "target": "lib/stripe.ts",
      "type": "template",
      "content": "import Stripe from 'stripe';\n\nlet _stripe: Stripe | null = null;\nexport const getStripe = (): Stripe => {\n  if (!_stripe) {\n    _stripe = new Stripe(process.env.STRIPE_SECRET_KEY as string, {\n      \n    });\n  }\n  return _stripe;\n};\n\n\nexport const getProducts = async ({ baseUrl }: { baseUrl?: string }): Promise<Stripe.Response<Stripe.ApiList<Stripe.Product>>> => {\n  try {\n    const response = await fetch(`${baseUrl}/api/products`)\n\n    if (!response.ok) {\n      throw new Error(`Failed to fetch products: ${response.status} ${response.statusText}`)\n    }\n\n    return await response.json()\n  } catch (error) {\n    console.error('Error fetching products:', error)\n    throw error\n  }\n}\n\nexport const getProduct = async ({ baseUrl, product_id }: { baseUrl?: string, product_id: string }): Promise<Stripe.Product> => {\n  try {\n    const response = await fetch(`${baseUrl}/api/product?product_id=${product_id}`)\n\n    if (!response.ok) {\n      throw new Error(`Failed to fetch product: ${response.status} ${response.statusText}`)\n    }\n\n    return await response.json()\n  } catch (error) {\n    console.error('Error fetching product:', error)\n    throw error\n  }\n}\n\nexport const getCustomer = async ({ baseUrl, customer_id }: { baseUrl?: string, customer_id: string }): Promise<Stripe.Customer> => {\n  try {\n    const response = await fetch(`${baseUrl}/api/customer?customer_id=${customer_id}`)\n\n    if (!response.ok) {\n      throw new Error(`Failed to fetch customer: ${response.status} ${response.statusText}`)\n    }\n\n    return await response.json()\n  } catch (error) {\n    console.error('Error fetching customer:', error)\n    throw error\n  }\n}\n\nexport const getCustomerSubscriptions = async ({ baseUrl, customer_id }: { baseUrl?: string, customer_id: string }): Promise<Stripe.Response<Stripe.ApiList<Stripe.Subscription>>> => {\n  try {\n    const response = await fetch(`${baseUrl}/api/customer/subscriptions?customer_id=${customer_id}`)\n\n    if (!response.ok) {\n      throw new Error(`Failed to fetch customer subscriptions: ${response.status} ${response.statusText}`)\n    }\n\n    return await response.json()\n  } catch (error) {\n    console.error('Error fetching customer subscriptions:', error)\n    throw error\n  }\n}\n\nexport const getCustomerPayments = async ({ baseUrl, customer_id }: { baseUrl?: string, customer_id: string }): Promise<Stripe.PaymentIntent[]> => {\n  try {\n    const response = await fetch(`${baseUrl}/api/customer/payments?customer_id=${customer_id}`)\n\n    if (!response.ok) {\n      throw new Error(`Failed to fetch customer payments: ${response.status} ${response.statusText}`)\n    }\n\n    return await response.json()\n  } catch (error) {\n    console.error('Error fetching customer payments:', error)\n    throw error\n  }\n}\n\nexport const createCustomer = async ({ baseUrl, customer }: { baseUrl?: string, customer: { email: string; name: string; phone_number?: string | null } }): Promise<Stripe.Customer> => {\n  try {\n    const response = await fetch(`${baseUrl}/api/customer`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(customer),\n    })\n\n    if (!response.ok) {\n      throw new Error(`Failed to create customer: ${response.status} ${response.statusText}`)\n    }\n\n    return await response.json()\n  } catch (error) {\n    console.error('Error creating customer:', error)\n    throw error\n  }\n}\n\nexport const updateCustomer = async ({ baseUrl, customer_id, customer }: { baseUrl?: string, customer_id: string, customer: { name?: string | null; phone_number?: string | null } }): Promise<Stripe.Customer> => {\n  try {\n    const response = await fetch(`${baseUrl}/api/customer?customer_id=${customer_id}`, {\n      method: 'PUT',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(customer),\n    })\n\n    if (!response.ok) {\n      throw new Error(`Failed to update customer: ${response.status} ${response.statusText}`)\n    }\n\n    return await response.json()\n  } catch (error) {\n    console.error('Error updating customer:', error)\n    throw error\n  }\n}\n\nexport const checkout = async ({ baseUrl, productCart, customer, return_url, metadata }: { baseUrl?: string, productCart: Array<{ name: string; quantity: number; amount: number }>, customer: { email: string; name: string }, return_url: string, metadata?: Record<string, string> }): Promise<{ url: string }> => {\n  try {\n    const response = await fetch(`${baseUrl}/api/checkout`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({ productCart, customer, return_url, metadata }),\n    })\n\n    if (!response.ok) {\n      throw new Error(`Failed to checkout: ${response.status} ${response.statusText}`)\n    }\n\n    return await response.json()\n  } catch (error) {\n    console.error('Error checking out:', error)\n    throw error\n  }\n}"
    },
    {
      "target": "hooks/useBilling.ts",
      "type": "template",
      "content": "import { checkout, createCustomer, getCustomer, getCustomerPayments, getCustomerSubscriptions, getProduct, getProducts, updateCustomer } from \"@/lib/stripe\";\nimport { useState, useCallback } from \"react\";\nimport Stripe from \"stripe\";\n\ninterface UseBillingState {\n  loading: boolean;\n  error: string | null;\n}\n\nexport function useBilling({ baseUrl }: { baseUrl?: string } = {}) {\n  const resolvedBaseUrl =\n    baseUrl ? baseUrl : '/';\n\n  const [state, setState] = useState<UseBillingState>({\n    loading: false,\n    error: null,\n  });\n\n  const [products, setProducts] = useState<Stripe.Response<Stripe.ApiList<Stripe.Product>> | null>(null);\n  const [customer, setCustomer] = useState<Stripe.Customer | null>(null);\n\n  const setLoading = useCallback((loading: boolean) => {\n    setState((prev) => ({ ...prev, loading }));\n  }, []);\n\n  const setError = useCallback((error: string | null) => {\n    setState((prev) => ({ ...prev, error }));\n  }, []);\n\n  const handleAsyncOperation = useCallback(\n    async <T>(\n      operation: () => Promise<T>,\n      operationName: string\n    ): Promise<T> => {\n      try {\n        setLoading(true);\n        setError(null);\n        const result = await operation();\n        return result;\n      } catch (error) {\n        const errorMessage =\n          error instanceof Error ? error.message : `Failed to ${operationName}`;\n        setError(errorMessage);\n        throw error;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [setLoading, setError]\n  );\n\n  const fetchProducts = useCallback(async (): Promise<Stripe.Response<Stripe.ApiList<Stripe.Product>>> => {\n    const result = await handleAsyncOperation(\n      () => getProducts({ baseUrl: resolvedBaseUrl }),\n      \"fetch products\"\n    );\n    setProducts(result);\n    return result;\n  }, [handleAsyncOperation, resolvedBaseUrl]);\n\n  const fetchProduct = useCallback(\n    async (product_id: string): Promise<Stripe.Product> => {\n      return handleAsyncOperation(\n        () => getProduct({ baseUrl: resolvedBaseUrl, product_id }),\n        \"fetch product\"\n      );\n    },\n    [handleAsyncOperation, resolvedBaseUrl]\n  );\n\n  const fetchCustomer = useCallback(\n    async (customer_id: string): Promise<Stripe.Customer> => {\n      const result = await handleAsyncOperation(\n        () => getCustomer({ baseUrl: resolvedBaseUrl, customer_id }),\n        \"fetch customer\"\n      );\n      setCustomer(result);\n      return result;\n    },\n    [handleAsyncOperation, resolvedBaseUrl]\n  );\n\n  const fetchCustomerSubscriptions = useCallback(\n    async (customer_id: string): Promise<Stripe.Response<Stripe.ApiList<Stripe.Subscription>>> => {\n      return handleAsyncOperation(\n        () =>\n          getCustomerSubscriptions({ baseUrl: resolvedBaseUrl, customer_id }),\n        \"fetch customer subscriptions\"\n      );\n    },\n    [handleAsyncOperation, resolvedBaseUrl]\n  );\n\n  const fetchCustomerPayments = useCallback(\n    async (customer_id: string): Promise<Stripe.PaymentIntent[]> => {\n      return handleAsyncOperation(\n        () => getCustomerPayments({ baseUrl: resolvedBaseUrl, customer_id }),\n        \"fetch customer payments\"\n      );\n    },\n    [handleAsyncOperation, resolvedBaseUrl]\n  );\n\n  const createNewCustomer = useCallback(\n    async (\n      newCustomer: { email: string; name: string; phone_number?: string | null }\n    ): Promise<Stripe.Customer> => {\n      const result = await handleAsyncOperation(\n        () =>\n          createCustomer({ baseUrl: resolvedBaseUrl, customer: newCustomer }),\n        \"create customer\"\n      );\n      setCustomer(result);\n      return result;\n    },\n    [handleAsyncOperation, resolvedBaseUrl]\n  );\n\n  const updateExistingCustomer = useCallback(\n    async (\n      customer_id: string,\n      updatedCustomer: { name?: string | null; phone_number?: string | null }\n    ): Promise<Stripe.Customer> => {\n      const result = await handleAsyncOperation(\n        () =>\n          updateCustomer({\n            baseUrl: resolvedBaseUrl,\n            customer_id,\n            customer: updatedCustomer,\n          }),\n        \"update customer\"\n      );\n      setCustomer(result);\n      return result;\n    },\n    [handleAsyncOperation, resolvedBaseUrl]\n  );\n\n  const createCheckout = useCallback(\n    async (\n      productCart: Array<{ name: string; quantity: number; amount: number }>,\n      customer: { email: string; name: string },\n      return_url: string,\n      metadata?: Record<string, string>\n    ): Promise<{ url: string }> => {\n      return handleAsyncOperation(\n        () =>\n          checkout({\n            baseUrl: resolvedBaseUrl,\n            productCart,\n            customer,\n            return_url,\n            metadata,\n          }),\n        \"create checkout\"\n      );\n    },\n    [handleAsyncOperation, resolvedBaseUrl]\n  );\n\n  const clearError = useCallback(() => {\n    setError(null);\n  }, [setError]);\n\n  return {\n    loading: state.loading,\n    error: state.error,\n    products,\n    customer,\n    clearError,\n    fetchProducts,\n    fetchProduct,\n    fetchCustomer,\n    fetchCustomerSubscriptions,\n    fetchCustomerPayments,\n    createNewCustomer,\n    updateExistingCustomer,\n    createCheckout,\n  };\n}\n"
    },
    {
      "target": "app/api/checkout/route.ts",
      "type": "template",
      "content": "import { z } from \"zod\";\nimport {NextRequest, NextResponse} from \"next/server\";\nimport { getStripe } from \"@/lib/stripe\";\n\n\nconst productCartItemSchema = z.object({\n    name: z.string().min(1),\n    quantity: z.number().int().min(1),\n    amount: z.number().int().min(1),\n});\n\nconst stripe = getStripe();\n\nconst customerSchema = z.object({\n    email: z.string().email(),\n    name: z.string().min(1)\n});\n\nconst checkoutSessionSchema = z.object({\n    productCart: z.array(productCartItemSchema).min(1),\n    customer: customerSchema,\n    return_url: z.string().url,\n    metadata: z.record(z.string(), z.string()).optional()\n\n})\n\n\nexport async function POST(req: NextRequest) {\n    try{\n        const body = await req.json();\n        const validation = checkoutSessionSchema.safeParse(body);\n\n        if(!validation.success) {\n            return NextResponse.json({\n                error: \"Validation failed\",\n                details: validation.error.issues.map(issue => ({\n                    field: issue.path.join(\".\"),\n                    message: issue.message\n                }))\n\n            }\n            , {status: 400}\n            )\n        }\n\n        const {productCart, customer, return_url, metadata} = validation.data;\n\n        const session = await stripe?.checkout.sessions.create({\n            payment_method_types: [\"card\"],\n            line_items: productCart.map(item => ({\n                price_data: {\n                    currency: \"usd\",\n                    product_data: {name: item.name},\n                    unit_amount: item.amount\n                },\n                quantity: item.quantity\n            })),\n            mode: \"payment\",\n            customer_email: customer.email,\n            success_url: `${return_url}?status=success&session_id={CHECKOUT_SESSION_ID}`,\n            cancel_url: `${return_url}?status=cancelled`,\n            metadata\n        });\n        return NextResponse.json({url: session.url})\n    } catch (error) {\n        console.error(\"Stripe checkout error: \", error);\n        return NextResponse.json({error: \"Internal server error\"}, {status: 500})\n\n    }\n\n}   "
    },
    {
      "target": "app/api/customer/payments/route.ts",
      "type": "template",
      "content": "import { getStripe } from \"@/lib/stripe\";\nimport { NextResponse } from \"next/server\";\nimport { z } from \"zod\";\n\n\nconst stripe = getStripe();\n\nconst paymentQuerySchema = z.object({\n  customer_id: z.string().min(1, \"Customer ID is required\"),\n});\n\nexport async function GET(request: Request) {\n  try {\n    const url = new URL(request.url);\n    const customer_id = url.searchParams.get(\"customer_id\");\n\n    const validationResult = paymentQuerySchema.safeParse({ customer_id });\n    if (!validationResult.success) {\n      return NextResponse.json(\n        { error: validationResult.error.issues[0].message },\n        { status: 400 }\n      );\n    }\n\n    const validatedParams = validationResult.data;\n\n    \n    const paymentIntents = await stripe.paymentIntents.list({\n      customer: validatedParams.customer_id,\n      limit: 10\n    });\n\n    return NextResponse.json(paymentIntents.data);\n  } catch (error) {\n    console.error(\"Error fetching customer payments:\", error);\n    return NextResponse.json(\n      { error: \"Failed to fetch customer payments\" },\n      { status: 500 }\n    );\n  }\n}\n"
    },
    {
      "target": "app/api/customer/route.ts",
      "type": "template",
      "content": "\nimport { getStripe } from \"@/lib/stripe\";\nimport { NextResponse } from \"next/server\";\nimport { z } from \"zod\";\n\nconst stripe = getStripe();\n\nconst customerIdSchema = z.object({\n    customer_id: z.string().min(1, \"Customer ID is required\"),\n});\n\nconst createCustomerSchema = z.object({\n    email: z.string().email(\"Invalid email format\"),\n    name: z.string().min(1, \"Name is required\"),\n    phone_number: z.string().optional().nullable(),\n});\n\nconst updateCustomerSchema = z.object({\n    name: z.string().optional().nullable(),\n    phone_number: z.string().optional().nullable(),\n});\n\nexport async function GET(request: Request) {\n    try {\n        const url = new URL(request.url);\n        const queryParams = {\n            customer_id: url.searchParams.get('customer_id'),\n        };\n        const validationResult = customerIdSchema.safeParse(queryParams);\n\n        if (!validationResult.success) {\n            return NextResponse.json(\n                { error: validationResult.error.issues[0].message },\n                { status: 400 }\n            );\n        }\n\n        const { customer_id } = validationResult.data;\n        const customer = await stripe.customers.retrieve(customer_id);\n        return NextResponse.json(customer);\n    } catch (error) {\n        if (error instanceof stripe.errors.StripeError) {\n           return NextResponse.json({ error: error.message }, { status: 400 });\n        }\n\n        console.error('Error retrieving customer:', error);\n        return NextResponse.json(\n            { error: 'Failed to retrieve customer' },\n            { status: 500 }\n        );\n    }\n}\n\nexport async function POST(request: Request) {\n    try {\n        const body = await request.json();\n\n        const validationResult = createCustomerSchema.safeParse(body);\n        if (!validationResult.success) {\n            return NextResponse.json(\n                { error: validationResult.error.issues[0].message },\n                { status: 400 }\n            );\n        }\n\n        const customer = await stripe.customers.create({\n             email: validationResult.data.email,\n             name: validationResult.data.name,\n             phone: validationResult.data.phone_number ?? undefined,\n        });\n        return NextResponse.json(customer);\n    } catch (error) {\n        if (error instanceof stripe.errors.StripeError) {\n        return NextResponse.json({ error: error.message }, { status: 400 });\n        }\n\n        console.error('Error creating customer:', error);\n        return NextResponse.json(\n            { error: 'Failed to create customer' },\n            { status: 500 }\n        );\n    }\n}\n\nexport async function PUT(request: Request) {\n    try {\n        const url = new URL(request.url);\n        const customer_id = url.searchParams.get('customer_id');\n        const body = await request.json();\n\n        const customerIdValidation = customerIdSchema.safeParse({ customer_id });\n        if (!customerIdValidation.success) {\n            return NextResponse.json(\n                { error: customerIdValidation.error.issues[0].message },\n                { status: 400 }\n            );\n        }\n\n        const updateValidation = updateCustomerSchema.safeParse(body);\n        if (!updateValidation.success) {\n            return NextResponse.json(\n                { error: updateValidation.error.issues[0].message },\n                { status: 400 }\n            );\n        }\n\n        const { customer_id: validCustomerId } = customerIdValidation.data;\n\n        const updateData = Object.fromEntries(\n            Object.entries(updateValidation.data).filter(([, v]) => v !== null)\n        );\n        const customer = await stripe.customers.update(validCustomerId, updateData);\n        return NextResponse.json(customer);\n    } catch (error) {\n        if (error instanceof stripe.errors.StripeError) {\n            return NextResponse.json({ error: error.message }, { status: 400 });\n        }\n\n        console.error('Error updating customer:', error);\n        return NextResponse.json(\n            { error: 'Failed to update customer' },\n            { status: 500 }\n        );\n    }\n}"
    },
    {
      "target": "app/api/customer/subscription/route.ts",
      "type": "template",
      "content": "\nimport { getStripe } from \"@/lib/stripe\";\nimport { NextResponse } from \"next/server\";\nimport { z } from \"zod\";\n\nconst subscriptionQuerySchema = z.object({\n    customer_id: z.string().min(1, \"Customer ID is required\"),\n});\n\nconst stripe = getStripe();\n\nexport async function GET(request: Request) {\n    try {\n        const url = new URL(request.url);\n        const customer_id = url.searchParams.get('customer_id');\n\n        const validationResult = subscriptionQuerySchema.safeParse({ customer_id });\n\n        if (!validationResult.success) {\n            return NextResponse.json(\n                { error: validationResult.error.issues[0].message },\n                { status: 400 }\n            );\n        }\n\n        const subscriptions = await stripe.subscriptions.list({\n            customer: validationResult.data.customer_id,\n            status: 'all',\n            expand: [\"data.default_payment_method\"]\n        });\n\n        return NextResponse.json(subscriptions);\n    } catch (error) {\n        console.error('Error fetching subscriptions:', error);\n        return NextResponse.json({ error: 'Failed to fetch subscriptions' }, { status: 500 });\n    }\n}"
    },
    {
      "target": "app/api/product/route.ts",
      "type": "template",
      "content": "\nimport { getStripe } from \"@/lib/stripe\";\nimport { NextResponse } from \"next/server\";\nimport { z } from \"zod\";\n\nconst stripe = getStripe();\n\nconst productIdSchema = z.object({\n    product_id: z.string().min(1, \"Product ID is required\"),\n});\n\nexport async function GET(request: Request) {\n    try {\n        const url = new URL(request.url);\n        const queryParams = {\n            product_id: url.searchParams.get('product_id'),\n        };\n        const validationResult = productIdSchema.safeParse(queryParams);\n\n        if (!validationResult.success) {\n            return NextResponse.json(\n                { error: validationResult.error.issues[0].message },\n                { status: 400 }\n            );\n        }\n\n        const { product_id } = validationResult.data;\n\n        const product = await stripe.products.retrieve(product_id);\n        return NextResponse.json(product);\n    } catch (error) {\n        if (error instanceof stripe.errors.StripeError) {\n        return NextResponse.json({ error: error.message }, { status: 400 });\n        }\n        console.error('Error retrieving product:', error);\n        return NextResponse.json(\n            { error: 'Failed to retrieve product' },\n            { status: 500 }\n        );\n    }\n}"
    },
    {
      "target": "app/api/products/route.ts",
      "type": "template",
      "content": "import { getStripe } from \"@/lib/stripe\";\nimport { NextResponse } from \"next/server\";\n\nconst stripe = getStripe();\n\nexport async function GET() {\n    try {\n        const products = await stripe.products.list();\n        return NextResponse.json(products);\n    } catch (error) {\n        if (error instanceof stripe.errors.StripeError) {\n        return NextResponse.json({ error: error.message }, { status: 400 });\n        }\n        console.error('Error fetching products:', error);\n        return NextResponse.json(\n            { error: \"Failed to fetch products\" },\n            { status: 500 }\n        );\n    }\n}"
    },
    {
      "target": "app/api/webhook/route.ts",
      "type": "template",
      "content": "import { headers } from \"next/headers\";\nimport { getStripe } from \"@/lib/stripe\";\n\nconst stripe = getStripe();\n\nexport async function POST(req: Request) {\n  const body = await req.text();\n  const sig = (await headers()).get(\"stripe-signature\");\n\n  let event;\n  try {\n    event = stripe.webhooks.constructEvent(\n      body,\n      sig!,\n      process.env.STRIPE_WEBHOOK_SECRET!\n    );\n  } catch (err) {\n    console.error(\"Webhook verification failed:\", err);\n    return Response.json({ error: \"Invalid signature\" }, { status: 400 });\n  }\n\n  try {\n    switch (event.type) {\n      case \"customer.subscription.created\":\n      case \"customer.subscription.updated\":\n      case \"customer.subscription.deleted\": {\n        const subscription = event.data.object;\n        console.log(\"Subscription event:\", subscription.id, event.type);\n        break;\n      }\n\n      case \"payment_intent.succeeded\": {\n        const paymentIntent = event.data.object;\n        console.log(\"Payment succeeded:\", paymentIntent.id);\n        break;\n      }\n\n      case \"checkout.session.completed\": {\n        const session = event.data.object;\n        console.log(\"Checkout completed:\", session.id);\n        break;\n      }\n\n      default:\n        console.log(`Unhandled event type ${event.type}`);\n    }\n\n    return Response.json({ received: true }, { status: 200 });\n  } catch (error) {\n    console.error(\"Error handling event:\", error);\n    return Response.json({ error: \"Webhook handling failed\" }, { status: 500 });\n  }\n}\n"
    },
    {
      "target": ".env.example",
      "type": "template",
      "content": "DODO_PAYMENTS_API_KEY=your-api-key\nDODO_PAYMENTS_WEBHOOK_KEY=your-webhook-secret\nDODO_PAYMENTS_RETURN_URL=https://yourdomain.com/checkout/success\nDODO_PAYMENTS_ENVIRONMENT=\"test\"or\"live\"\n\nSTRIPE_SECRET_KEY=your=stripe-secret-key"
    }
  ],
  "dependencies": [
    "stripe",
    "standardwebhooks",
    "zod"
  ]
}