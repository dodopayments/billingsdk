{
  "name": "nestjs-dodopayments",
  "description": "DodoPayments template for NestJS",
  "framework": "nestjs",
  "files": [
    {
      "target": "tsconfig.json",
      "type": "template",
      "content": "{\n  \"compilerOptions\": {\n    \"module\": \"commonjs\",\n    \"declaration\": true,\n    \"removeComments\": true,\n    \"emitDecoratorMetadata\": true,\n    \"experimentalDecorators\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"target\": \"ES2021\",\n    \"lib\": [\"ES2021\"],\n    \"sourceMap\": true,\n    \"outDir\": \"./dist\",\n    \"incremental\": true,\n    \"skipLibCheck\": true,\n    \"strictNullChecks\": false,\n    \"noImplicitAny\": false,\n    \"strictBindCallApply\": false,\n    \"strictFunctionTypes\": false,\n    \"noFallthroughCasesInSwitch\": false,\n    \"esModuleInterop\": true,\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"useDefineForClassFields\": false\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n"
    },
    {
      "target": "lib/dodopayments.ts",
      "type": "template",
      "content": "import { DodoPayments } from 'dodopayments'\n\nlet dodopaymentsClient: DodoPayments | null = null\n\nexport function getDodoPaymentsClient(): DodoPayments {\n  if (!dodopaymentsClient) {\n    const token = process.env.DODO_PAYMENTS_API_KEY\n    const environment = process.env.DODO_PAYMENTS_ENVIRONMENT as \"live_mode\" | \"test_mode\"\n\n    if (!token) {\n      throw new Error(`\n        DODO_PAYMENTS_API_KEY environment variable is missing.\n        \n        Please check:\n        1. Your .env file exists in the project root\n        2. The file contains: DODO_PAYMENTS_API_KEY=<your-api-key>\n        3. You've restarted your development server\n        4. No extra quotes or spaces in the .env file\n      `)\n    }\n\n    if (!environment || (environment !== \"live_mode\" && environment !== \"test_mode\")) {\n      throw new Error('DODO_PAYMENTS_ENVIRONMENT must be either \"live_mode\" or \"test_mode\"')\n    }\n\n    dodopaymentsClient = new DodoPayments({\n      bearerToken: token,\n      environment: environment,\n    })\n  }\n\n  return dodopaymentsClient\n}\n"
    },
    {
      "target": "modules/dodopayments/dodopayments.module.ts",
      "type": "template",
      "content": "import { Module } from '@nestjs/common';\nimport { ProductsController } from './products.controller';\nimport { CustomerController } from './customer.controller';\nimport { CheckoutController } from './checkout.controller';\nimport { SubscriptionsController } from './subscriptions.controller';\nimport { PaymentsController } from './payments.controller';\nimport { WebhookController } from './webhook.controller';\n\n@Module({\n  controllers: [\n    ProductsController,\n    CustomerController,\n    CheckoutController,\n    SubscriptionsController,\n    PaymentsController,\n    WebhookController,\n  ],\n})\nexport class DodopaymentsModule {}\n"
    },
    {
      "target": "modules/dodopayments/checkout.controller.ts",
      "type": "template",
      "content": "import { Controller, Post, Body, HttpException, HttpStatus } from '@nestjs/common';\nimport { getDodoPaymentsClient } from '../../lib/dodopayments';\nimport { z } from 'zod';\n\nconst productCartItemSchema = z.object({\n  product_id: z.string().min(1, \"Product ID is required\"),\n  quantity: z.number().int().min(1, \"Quantity must be at least 1\"),\n  amount: z.number().int().min(0).optional(),\n});\n\nconst attachExistingCustomerSchema = z.object({\n  customer_id: z.string().min(1, \"Customer ID is required\"),\n});\n\nconst newCustomerSchema = z.object({\n  email: z.string().email(\"Invalid email format\"),\n  name: z.string().min(1, \"Name is required\"),\n  phone_number: z.string().optional().nullable(),\n  create_new_customer: z.boolean().optional(),\n});\n\nconst customerSchema = z.union([attachExistingCustomerSchema, newCustomerSchema]);\n\nconst billingAddressSchema = z.object({\n  city: z.string().min(1, \"City is required\"),\n  country: z.string().regex(/^[A-Z]{2}$/, \"Country must be a 2-letter uppercase ISO code\"),\n  state: z.string().min(1, \"State is required\"),\n  street: z.string().min(1, \"Street address is required\"),\n  zipcode: z.string().min(1, \"Zipcode is required\"),\n});\n\nconst checkoutSessionSchema = z.object({\n  productCart: z.array(productCartItemSchema).min(1, \"At least one product is required\"),\n  customer: customerSchema,\n  billing_address: billingAddressSchema,\n  return_url: z.string().url(\"Return URL must be a valid URL\"),\n  customMetadata: z.record(z.string(), z.string()).optional(),\n});\n\ntype CheckoutSessionRequest = z.infer<typeof checkoutSessionSchema>;\n\n@Controller('dodopayments/checkout')\nexport class CheckoutController {\n  @Post()\n  async createCheckoutSession(@Body() body: CheckoutSessionRequest): Promise<any> {\n    try {\n      const validationResult = checkoutSessionSchema.safeParse(body);\n      if (!validationResult.success) {\n        throw new HttpException(\n          {\n            error: \"Validation failed\",\n            details: validationResult.error.issues.map(issue => ({\n              field: issue.path.join('.'),\n              message: issue.message\n            }))\n          },\n          HttpStatus.BAD_REQUEST\n        );\n      }\n\n      const { productCart, customer, billing_address, return_url, customMetadata } = validationResult.data;\n\n      const session = await getDodoPaymentsClient().checkoutSessions.create({\n        product_cart: productCart as any,\n        customer: customer as any,\n        billing_address: billing_address as any,\n        return_url: return_url,\n        metadata: customMetadata,\n      });\n\n      return session;\n    } catch (error) {\n      console.error('Error in checkout POST handler:', error);\n      if (error instanceof HttpException) {\n        throw error;\n      }\n      throw new HttpException('Internal server error', HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n  }\n}\n"
    },
    {
      "target": "modules/dodopayments/customer.controller.ts",
      "type": "template",
      "content": "import { Controller, Get, Post, Put, Query, Body, HttpException, HttpStatus } from '@nestjs/common';\nimport { getDodoPaymentsClient } from '../../lib/dodopayments';\nimport { z } from 'zod';\n\nconst customerCreateSchema = z.object({\n  email: z.string().email(\"Invalid email format\"),\n  name: z.string().min(1, \"Name is required\"),\n  phone_number: z.string().optional().nullable(),\n});\n\nconst customerUpdateSchema = z.object({\n  email: z.string().email(\"Invalid email format\").optional(),\n  name: z.string().min(1, \"Name is required\").optional(),\n  phone_number: z.string().optional().nullable(),\n});\n\ntype CustomerCreateRequest = z.infer<typeof customerCreateSchema>;\ntype CustomerUpdateRequest = z.infer<typeof customerUpdateSchema>;\n\n@Controller('dodopayments/customer')\nexport class CustomerController {\n  @Get()\n  async getCustomer(@Query('customer_id') customer_id?: string): Promise<any> {\n    try {\n      if (!customer_id) {\n        throw new HttpException('customer_id is required', HttpStatus.BAD_REQUEST);\n      }\n\n      const customer = await getDodoPaymentsClient().customers.retrieve(customer_id);\n      return customer;\n    } catch (error) {\n      console.error('Error fetching customer:', error);\n      if (error instanceof HttpException) {\n        throw error;\n      }\n      throw new HttpException('Internal server error', HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n  }\n\n  @Post()\n  async createCustomer(@Body() body: CustomerCreateRequest): Promise<any> {\n    try {\n      const validationResult = customerCreateSchema.safeParse(body);\n      if (!validationResult.success) {\n        throw new HttpException(\n          {\n            error: \"Validation failed\",\n            details: validationResult.error.issues.map(issue => ({\n              field: issue.path.join('.'),\n              message: issue.message\n            }))\n          },\n          HttpStatus.BAD_REQUEST\n        );\n      }\n\n      const customer = await getDodoPaymentsClient().customers.create(validationResult.data as any);\n      return customer;\n    } catch (error) {\n      console.error('Error creating customer:', error);\n      if (error instanceof HttpException) {\n        throw error;\n      }\n      throw new HttpException('Internal server error', HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n  }\n\n  @Put()\n  async updateCustomer(@Query('customer_id') customer_id: string, @Body() body: CustomerUpdateRequest): Promise<any> {\n    try {\n      if (!customer_id) {\n        throw new HttpException('customer_id is required', HttpStatus.BAD_REQUEST);\n      }\n\n      const validationResult = customerUpdateSchema.safeParse(body);\n      if (!validationResult.success) {\n        throw new HttpException(\n          {\n            error: \"Validation failed\",\n            details: validationResult.error.issues.map(issue => ({\n              field: issue.path.join('.'),\n              message: issue.message\n            }))\n          },\n          HttpStatus.BAD_REQUEST\n        );\n      }\n\n      const customer = await getDodoPaymentsClient().customers.update(customer_id, validationResult.data as any);\n      return customer;\n    } catch (error) {\n      console.error('Error updating customer:', error);\n      if (error instanceof HttpException) {\n        throw error;\n      }\n      throw new HttpException('Internal server error', HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n  }\n\n  @Get('subscriptions')\n  async getCustomerSubscriptions(@Query('customer_id') customer_id?: string): Promise<any> {\n    try {\n      if (!customer_id) {\n        throw new HttpException('customer_id is required', HttpStatus.BAD_REQUEST);\n      }\n\n      const subscriptions = await getDodoPaymentsClient().subscriptions.list({\n        customer_id: customer_id\n      });\n      return subscriptions;\n    } catch (error) {\n      console.error('Error fetching customer subscriptions:', error);\n      if (error instanceof HttpException) {\n        throw error;\n      }\n      throw new HttpException('Internal server error', HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n  }\n\n  @Get('payments')\n  async getCustomerPayments(@Query('customer_id') customer_id?: string): Promise<any> {\n    try {\n      if (!customer_id) {\n        throw new HttpException('customer_id is required', HttpStatus.BAD_REQUEST);\n      }\n\n      const payments = await getDodoPaymentsClient().payments.list({\n        customer_id: customer_id\n      });\n      return payments;\n    } catch (error) {\n      console.error('Error fetching customer payments:', error);\n      if (error instanceof HttpException) {\n        throw error;\n      }\n      throw new HttpException('Internal server error', HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n  }\n}\n"
    },
    {
      "target": "modules/dodopayments/payments.controller.ts",
      "type": "template",
      "content": "import { Controller, Get, Query, HttpException, HttpStatus } from '@nestjs/common';\nimport { getDodoPaymentsClient } from '../../lib/dodopayments';\n\n@Controller('dodopayments/payments')\nexport class PaymentsController {\n  @Get()\n  async getPayment(@Query('payment_id') payment_id?: string): Promise<any> {\n    try {\n      if (!payment_id) {\n        throw new HttpException('payment_id is required', HttpStatus.BAD_REQUEST);\n      }\n\n      const payment = await getDodoPaymentsClient().payments.retrieve(payment_id);\n      return payment;\n    } catch (error) {\n      console.error('Error fetching payment:', error);\n      if (error instanceof HttpException) {\n        throw error;\n      }\n      throw new HttpException('Internal server error', HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n  }\n\n  @Get('list')\n  async getPaymentsList(\n    @Query('customer_id') customer_id?: string,\n    @Query('limit') limit?: string,\n    @Query('starting_after') starting_after?: string,\n  ): Promise<any> {\n    try {\n      const params: any = {};\n      if (customer_id) {\n        params.customer_id = customer_id;\n      }\n      if (limit) {\n        params.limit = parseInt(limit);\n      }\n      if (starting_after) {\n        params.starting_after = starting_after;\n      }\n\n      const payments = await getDodoPaymentsClient().payments.list(params);\n      return payments;\n    } catch (error) {\n      console.error('Error fetching payments list:', error);\n      throw new HttpException('Internal server error', HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n  }\n}\n"
    },
    {
      "target": "modules/dodopayments/products.controller.ts",
      "type": "template",
      "content": "import { Controller, Get, Query, HttpException, HttpStatus } from '@nestjs/common';\nimport { getDodoPaymentsClient } from '../../lib/dodopayments';\n\n@Controller('dodopayments/products')\nexport class ProductsController {\n  @Get()\n  async getProducts(\n    @Query('limit') limit?: string,\n    @Query('starting_after') starting_after?: string,\n  ): Promise<any> {\n    try {\n      const params: any = {};\n      if (limit) {\n        params.limit = parseInt(limit);\n      }\n      if (starting_after) {\n        params.starting_after = starting_after;\n      }\n\n      const products = await getDodoPaymentsClient().products.list(params);\n      return products;\n    } catch (error) {\n      console.error('Error fetching products:', error);\n      throw new HttpException('Internal server error', HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n  }\n\n  @Get('product')\n  async getProduct(@Query('product_id') product_id?: string): Promise<any> {\n    try {\n      if (!product_id) {\n        throw new HttpException('product_id is required', HttpStatus.BAD_REQUEST);\n      }\n\n      const product = await getDodoPaymentsClient().products.retrieve(product_id);\n      return product;\n    } catch (error) {\n      console.error('Error fetching product:', error);\n      if (error instanceof HttpException) {\n        throw error;\n      }\n      throw new HttpException('Internal server error', HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n  }\n}\n"
    },
    {
      "target": "modules/dodopayments/subscriptions.controller.ts",
      "type": "template",
      "content": "import { Controller, Get, Query, HttpException, HttpStatus } from '@nestjs/common';\nimport { getDodoPaymentsClient } from '../../lib/dodopayments';\n\n@Controller('dodopayments/subscriptions')\nexport class SubscriptionsController {\n  @Get()\n  async getSubscription(@Query('subscription_id') subscription_id?: string): Promise<any> {\n    try {\n      if (!subscription_id) {\n        throw new HttpException('subscription_id is required', HttpStatus.BAD_REQUEST);\n      }\n\n      const subscription = await getDodoPaymentsClient().subscriptions.retrieve(subscription_id);\n      return subscription;\n    } catch (error) {\n      console.error('Error fetching subscription:', error);\n      if (error instanceof HttpException) {\n        throw error;\n      }\n      throw new HttpException('Internal server error', HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n  }\n\n  @Get('list')\n  async getSubscriptionsList(\n    @Query('customer_id') customer_id?: string,\n    @Query('limit') limit?: string,\n    @Query('starting_after') starting_after?: string,\n  ): Promise<any> {\n    try {\n      const params: any = {};\n      if (customer_id) {\n        params.customer_id = customer_id;\n      }\n      if (limit) {\n        params.limit = parseInt(limit);\n      }\n      if (starting_after) {\n        params.starting_after = starting_after;\n      }\n\n      const subscriptions = await getDodoPaymentsClient().subscriptions.list(params);\n      return subscriptions;\n    } catch (error) {\n      console.error('Error fetching subscriptions list:', error);\n      throw new HttpException('Internal server error', HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n  }\n}\n"
    },
    {
      "target": "modules/dodopayments/webhook.controller.ts",
      "type": "template",
      "content": "import { Controller, Post, Req, Res } from '@nestjs/common';\nimport { Request, Response } from 'express';\nimport { Webhook } from \"standardwebhooks\";\nimport { getDodoPaymentsClient } from '../../lib/dodopayments';\n\n@Controller('dodopayments/webhook')\nexport class WebhookController {\n  private webhook = new Webhook(process.env.DODO_PAYMENTS_WEBHOOK_KEY!);\n\n  @Post()\n  async handleWebhook(@Req() req: Request, @Res() res: Response): Promise<any> {\n    try {\n      const rawBody = req.body;\n      const webhookHeaders = {\n        \"webhook-id\": req.headers[\"webhook-id\"] as string || \"\",\n        \"webhook-signature\": req.headers[\"webhook-signature\"] as string || \"\",\n        \"webhook-timestamp\": req.headers[\"webhook-timestamp\"] as string || \"\",\n      };\n\n      await this.webhook.verify(rawBody, webhookHeaders);\n      const payload = JSON.parse(rawBody.toString());\n\n      if (payload.data.payload_type === \"Subscription\") {\n        switch (payload.type) {\n          case \"subscription.active\":\n            const subscription = await getDodoPaymentsClient().subscriptions.retrieve(payload.data.subscription_id);\n            console.log(\"-------SUBSCRIPTION DATA START ---------\")\n            console.log(subscription)\n            console.log(\"-------SUBSCRIPTION DATA END ---------\")\n            break;\n          case \"subscription.failed\":\n            console.log(\"Subscription failed:\", payload.data.subscription_id);\n            break;\n          case \"subscription.cancelled\":\n            console.log(\"Subscription cancelled:\", payload.data.subscription_id);\n            break;\n          case \"subscription.renewed\":\n            console.log(\"Subscription renewed:\", payload.data.subscription_id);\n            break;\n          case \"subscription.on_hold\":\n            console.log(\"Subscription on hold:\", payload.data.subscription_id);\n            break;\n          default:\n            console.log(\"Unknown subscription event:\", payload.type);\n            break;\n        }\n      } else if (payload.data.payload_type === \"Payment\") {\n        switch (payload.type) {\n          case \"payment.succeeded\":\n            const paymentDataResp = await getDodoPaymentsClient().payments.retrieve(payload.data.payment_id)\n            console.log(\"-------PAYMENT DATA START ---------\")\n            console.log(paymentDataResp)\n            console.log(\"-------PAYMENT DATA END ---------\")\n            break;\n          case \"payment.failed\":\n            console.log(\"Payment failed:\", payload.data.payment_id);\n            break;\n          case \"payment.refunded\":\n            console.log(\"Payment refunded:\", payload.data.payment_id);\n            break;\n          default:\n            console.log(\"Unknown payment event:\", payload.type);\n            break;\n        }\n      }\n\n      res.status(200).json({ message: \"Webhook processed successfully\" });\n    } catch (error) {\n      console.error(\"Webhook verification failed:\", error);\n      res.status(400).json({ error: \"Webhook verification failed\" });\n    }\n  }\n}\n"
    },
    {
      "target": ".env.example",
      "type": "template",
      "content": "# DodoPayments Configuration\nDODO_PAYMENTS_API_KEY=your_api_key_here\nDODO_PAYMENTS_ENVIRONMENT=test_mode\nDODO_PAYMENTS_WEBHOOK_KEY=your_webhook_key_here\n\n# Server Configuration\nPORT=3000\nNODE_ENV=development\n\nSTRIPE_SECRET_KEY=\"your_secret_key_here\"\nSTRIPE_SECRET_KEY=sk_test_12345...\nSTRIPE_WEBHOOK_SECRET=whsec_12345\n"
    }
  ],
  "dependencies": [
    "dodopayments",
    "standardwebhooks",
    "zod",
    "@nestjs/common",
    "@nestjs/core",
    "@nestjs/platform-express",
    "reflect-metadata",
    "rxjs",
    "@types/express",
    "@nestjs/cli",
    "typescript",
    "ts-node"
  ]
}