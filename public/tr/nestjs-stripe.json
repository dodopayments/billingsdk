{
  "name": "nestjs-stripe",
  "description": "Stripe template for NestJS",
  "framework": "nestjs",
  "files": [
    {
      "target": "tsconfig.json",
      "type": "template",
      "content": "{\n  \"compilerOptions\": {\n    \"module\": \"commonjs\",\n    \"declaration\": true,\n    \"removeComments\": true,\n    \"emitDecoratorMetadata\": true,\n    \"experimentalDecorators\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"target\": \"ES2021\",\n    \"lib\": [\"ES2021\"],\n    \"sourceMap\": true,\n    \"outDir\": \"./dist\",\n    \"incremental\": true,\n    \"skipLibCheck\": true,\n    \"strictNullChecks\": false,\n    \"noImplicitAny\": false,\n    \"strictBindCallApply\": false,\n    \"strictFunctionTypes\": false,\n    \"noFallthroughCasesInSwitch\": false,\n    \"esModuleInterop\": true,\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"useDefineForClassFields\": false\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n"
    },
    {
      "target": "lib/stripe.ts",
      "type": "template",
      "content": "import Stripe from 'stripe';\n\nlet _stripe: Stripe | null = null;\nexport const getStripe = (): Stripe => {\n  const key = process.env.STRIPE_SECRET_KEY;\n  if(!key){\n    throw new Error(\"STRIPE_SECRET_KEY is not set\")\n  }\n  if (!_stripe) {\n    _stripe = new Stripe(process.env.STRIPE_SECRET_KEY as string, {\n      \n    });\n  }\n  return _stripe;\n};\n\n\n\nlet stripe = getStripe();\n\n\nexport type Product = Stripe.Product;\nexport type Customer = Stripe.Customer;\nexport type Subscription = Stripe.Subscription;\nexport type PaymentIntent = Stripe.PaymentIntent;\n\n\nexport async function getProducts(): Promise<Product[]> {\n  try {\n    const { data } = await stripe.products.list({ limit: 100 });\n    return data;\n  } catch (error) {\n    console.error('Error fetching products', error);\n    throw new Error('Failed to fetch products');\n  }\n}\n\nexport async function getProduct(product_id: string): Promise<Product> {\n  try {\n    return await stripe.products.retrieve(product_id);\n  } catch (error) {\n    console.error('Error fetching product', error);\n    throw new Error('Failed to fetch product');\n  }\n}\n\n\nexport async function getCustomer(customer_id: string): Promise<Customer | Stripe.DeletedCustomer> {\n  try {\n    const customer = await stripe.customers.retrieve(customer_id);\n    \n    if ((customer as Stripe.DeletedCustomer).deleted) {\n      return customer as Stripe.DeletedCustomer;\n    }\n    return customer as Customer;\n  } catch (error) {\n    console.error('Error fetching customer', error);\n    throw new Error('Failed to fetch customer');\n  }\n}\n\nexport async function createCustomer(params: Stripe.CustomerCreateParams): Promise<Customer> {\n  try {\n    return await stripe.customers.create(params);\n  } catch (error) {\n    console.error('Error creating customer', error);\n    throw new Error('Failed to create customer');\n  }\n}\n\nexport async function updateCustomer(customer_id: string, params: Stripe.CustomerUpdateParams): Promise<Customer> {\n  try {\n    return await stripe.customers.update(customer_id, params);\n  } catch (error) {\n    console.error('Error updating customer', error);\n    throw new Error('Failed to update customer');\n  }\n}\n\n\nexport async function getCustomerSubscriptions(customer_id: string): Promise<Subscription[]> {\n  try {\n    const { data } = await stripe.subscriptions.list({ customer: customer_id });\n    return data;\n  } catch (error) {\n    console.error('Error fetching subscriptions', error);\n    throw new Error('Failed to fetch subscriptions');\n  }\n}\n\n\nexport async function getCustomerPayments(customer_id: string): Promise<PaymentIntent[]> {\n  try {\n    const { data } = await stripe.paymentIntents.list({ customer: customer_id, limit: 100 });\n    return data;\n  } catch (error) {\n    console.error('Error fetching payments', error);\n    throw new Error('Failed to fetch payments');\n  }\n}\n\n\nexport async function checkout(opts: {\n  price_id: string;\n  customer_id?: string;\n  success_url: string;\n  cancel_url: string;\n}): Promise<{ checkout_url: string }> {\n  try {\n    const session = await stripe.checkout.sessions.create({\n      mode: 'subscription',\n      line_items: [{ price: opts.price_id, quantity: 1 }],\n      customer: opts.customer_id ?? '',\n      success_url: opts.success_url,\n      cancel_url: opts.cancel_url,\n    });\n    return { checkout_url: session.url! };\n  } catch (error) {\n    console.error('Error creating checkout session', error);\n    throw new Error('Failed to create checkout session');\n  }\n}\n"
    },
    {
      "target": "modules/stripe/stripe.module.ts",
      "type": "template",
      "content": "import { Module } from '@nestjs/common';\nimport { ProductsController } from './products.controller';\nimport { CustomerController } from './customer.controller';\nimport { CheckoutController } from './checkout.controller';\nimport { SubscriptionsController } from './subscriptions.controller';\nimport { PaymentsController } from './payments.controller';\nimport { WebhookController } from './webhook.controller';\n\n@Module({\n  controllers: [\n    ProductsController,\n    CustomerController,\n    CheckoutController,\n    SubscriptionsController,\n    PaymentsController,\n    WebhookController,\n  ],\n})\nexport class StripeModule {}\n"
    },
    {
      "target": "modules/stripe/checkout.controller.ts",
      "type": "template",
      "content": "import { Controller, Post, Body, HttpException, HttpStatus } from '@nestjs/common';\nimport { z } from 'zod';\nimport { getStripe } from '../../lib/stripe';\nimport type Stripe from 'stripe';\n\nconst productCartItemSchema = z.object({\n  price_id: z.string().min(1, \"Price ID is required\"),\n  quantity: z.number().int().min(1, \"Quantity must be at least 1\"),\n});\n\nconst attachExistingCustomerSchema = z.object({\n  customer_id: z.string().min(1, \"Customer ID is required\"),\n});\n\nconst newCustomerSchema = z.object({\n  email: z.string().email(\"Invalid email format\"),\n  name: z.string().min(1, \"Name is required\"),\n  phone_number: z.string().optional().nullable(),\n  create_new_customer: z.boolean().optional(),\n});\n\nconst customerSchema = z.union([attachExistingCustomerSchema, newCustomerSchema]);\n\nconst checkoutSessionSchema = z.object({\n  productCart: z.array(productCartItemSchema).min(1, \"At least one product is required\"),\n  customer: customerSchema.optional(),\n  success_url: z.string().url(\"Success URL must be a valid URL\"),\n  cancel_url: z.string().url(\"Cancel URL must be a valid URL\"),\n  metadata: z.record(z.string(), z.string()).optional(),\n});\n\ntype CheckoutSessionRequest = z.infer<typeof checkoutSessionSchema>;\n\n@Controller('checkout')\nexport class CheckoutController {\n  private stripe = getStripe();\n\n  @Post()\n  async createCheckoutSession(@Body() body: CheckoutSessionRequest): Promise<any> {\n    try {\n      const validationResult = checkoutSessionSchema.safeParse(body);\n      if (!validationResult.success) {\n        throw new HttpException(\n          {\n            error: \"Validation failed\",\n            details: validationResult.error.issues.map(issue => ({\n              field: issue.path.join('.'),\n              message: issue.message,\n            })),\n          },\n          HttpStatus.BAD_REQUEST\n        );\n      }\n\n      const { productCart, customer, success_url, cancel_url, metadata } = validationResult.data;\n\n      let customerId: string | undefined;\n      if (customer && 'email' in customer) {\n        const stripeCustomer = await this.stripe.customers.create({\n          email: customer.email ?? \"\",\n          name: customer.name ?? \"\",\n          phone: customer.phone_number ?? \"\",\n        });\n        customerId = stripeCustomer.id;\n      } else if (customer && 'customer_id' in customer) {\n        customerId = customer.customer_id;\n      }\n\n      const sessionParams: Stripe.Checkout.SessionCreateParams = {\n        payment_method_types: [\"card\"],\n        line_items: productCart.map(item => ({\n          price: item.price_id,\n          quantity: item.quantity,\n        })),\n        mode: \"payment\",\n        success_url: success_url + \"?session_id={CHECKOUT_SESSION_ID}\",\n        cancel_url: cancel_url,\n        \n        ...(metadata ? { metadata } : {}),\n      };\n\n      if (customerId) {\n        sessionParams.customer = customerId;\n      }\n\n      const session = await this.stripe.checkout.sessions.create(sessionParams);\n\n      return { url: session.url };\n    } catch (error) {\n      console.error('Stripe checkout error:', error);\n      if (error instanceof HttpException) {\n        throw error;\n      }\n      throw new HttpException('Internal server error', HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n  }\n}\n"
    },
    {
      "target": "modules/stripe/customer.controller.ts",
      "type": "template",
      "content": "import { Controller, Get, Post, Put, Query, Body, HttpException, HttpStatus } from '@nestjs/common';\nimport { getStripe } from '../../lib/stripe';\nimport { z } from 'zod';\nimport type Stripe from 'stripe';\n\nconst customerCreateSchema = z.object({\n  email: z.string().email(\"Invalid email format\"),\n  name: z.string().min(1, \"Name is required\"),\n  phone_number: z.string().optional().nullable(),\n});\n\nconst customerUpdateSchema = z.object({\n  email: z.string().email(\"Invalid email format\").optional(),\n  name: z.string().min(1, \"Name is required\").optional(),\n  phone_number: z.string().optional().nullable(),\n});\n\ntype CustomerCreateRequest = z.infer<typeof customerCreateSchema>;\ntype CustomerUpdateRequest = z.infer<typeof customerUpdateSchema>;\n\n@Controller('customer')\nexport class CustomerController {\n  private stripe = getStripe();\n\n  @Get()\n  async getCustomer(@Query('customer_id') customer_id?: string): Promise<any> {\n    try {\n      if (!customer_id) {\n        throw new HttpException('customer_id is required', HttpStatus.BAD_REQUEST);\n      }\n\n      const customer = await this.stripe.customers.retrieve(customer_id);\n      return customer;\n    } catch (error) {\n      console.error('Error fetching customer:', error);\n      if (error instanceof HttpException) {\n        throw error;\n      }\n      throw new HttpException('Internal server error', HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n  }\n\n  @Post()\n  async createCustomer(@Body() body: CustomerCreateRequest): Promise<any> {\n    try {\n      const validationResult = customerCreateSchema.safeParse(body);\n      if (!validationResult.success) {\n        throw new HttpException(\n          {\n            error: \"Validation failed\",\n            details: validationResult.error.issues.map(issue => ({\n              field: issue.path.join('.'),\n              message: issue.message\n            }))\n          },\n          HttpStatus.BAD_REQUEST\n        );\n      }\n\n      const customer = await this.stripe.customers.create({\n        email: validationResult.data.email,\n        name: validationResult.data.name,\n        phone: validationResult.data.phone_number ?? \"\",\n      });\n\n      return customer;\n    } catch (error) {\n      console.error('Error creating customer:', error);\n      if (error instanceof HttpException) {\n        throw error;\n      }\n      throw new HttpException('Internal server error', HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n  }\n\n  @Put()\n  async updateCustomer(@Query('customer_id') customer_id: string, @Body() body: CustomerUpdateRequest): Promise<any> {\n    try {\n      if (!customer_id) {\n        throw new HttpException('customer_id is required', HttpStatus.BAD_REQUEST);\n      }\n\n      const validationResult = customerUpdateSchema.safeParse(body);\n      if (!validationResult.success) {\n        throw new HttpException(\n          {\n            error: \"Validation failed\",\n            details: validationResult.error.issues.map(issue => ({\n              field: issue.path.join('.'),\n              message: issue.message\n            }))\n          },\n          HttpStatus.BAD_REQUEST\n        );\n      }\n\n      const updateData: Stripe.CustomerUpdateParams = {};\n      if (validationResult.data.email) updateData.email = validationResult.data.email;\n      if (validationResult.data.name) updateData.name = validationResult.data.name;\n      if (validationResult.data.phone_number) updateData.phone = validationResult.data.phone_number;\n\n      const customer = await this.stripe.customers.update(customer_id, updateData);\n      return customer;\n    } catch (error) {\n      console.error('Error updating customer:', error);\n      if (error instanceof HttpException) {\n        throw error;\n      }\n      throw new HttpException('Internal server error', HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n  }\n\n  @Get('subscriptions')\n  async getCustomerSubscriptions(@Query('customer_id') customer_id?: string): Promise<any> {\n    try {\n      if (!customer_id) {\n        throw new HttpException('customer_id is required', HttpStatus.BAD_REQUEST);\n      }\n\n      const subscriptions = await this.stripe.subscriptions.list({\n        customer: customer_id,\n        limit: 100,\n      });\n\n      return subscriptions.data;\n    } catch (error) {\n      console.error('Error fetching customer subscriptions:', error);\n      if (error instanceof HttpException) {\n        throw error;\n      }\n      throw new HttpException('Internal server error', HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n  }\n\n  @Get('payments')\n  async getCustomerPayments(@Query('customer_id') customer_id?: string): Promise<any> {\n    try {\n      if (!customer_id) {\n        throw new HttpException('customer_id is required', HttpStatus.BAD_REQUEST);\n      }\n\n      const paymentIntents = await this.stripe.paymentIntents.list({\n        customer: customer_id,\n        limit: 100,\n      });\n\n      return paymentIntents.data;\n    } catch (error) {\n      console.error('Error fetching customer payments:', error);\n      if (error instanceof HttpException) {\n        throw error;\n      }\n      throw new HttpException('Internal server error', HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n  }\n}\n"
    },
    {
      "target": "modules/stripe/payments.controller.ts",
      "type": "template",
      "content": "import { Controller, Get, Query, HttpException, HttpStatus } from '@nestjs/common';\nimport { getStripe } from '../../lib/stripe';\n\n@Controller('payments')\nexport class PaymentsController {\n  private stripe = getStripe();\n\n  @Get()\n  async getPayment(@Query('payment_id') payment_id?: string): Promise<any> {\n    try {\n      if (!payment_id) {\n        throw new HttpException('payment_id is required', HttpStatus.BAD_REQUEST);\n      }\n\n      const payment = await this.stripe.paymentIntents.retrieve(payment_id);\n      return payment;\n    } catch (error) {\n      console.error('Error fetching payment:', error);\n      if (error instanceof HttpException) {\n        throw error;\n      }\n      throw new HttpException('Internal server error', HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n  }\n\n  @Get('list')\n  async getPaymentsList(\n    @Query('customer_id') customer_id?: string,\n    @Query('limit') limit?: string,\n    @Query('starting_after') starting_after?: string,\n  ): Promise<any> {\n    try {\n      const params: any = {};\n      if (customer_id) {\n        params.customer_id = customer_id;\n      }\n      if (limit) {\n        params.limit = parseInt(limit);\n      }\n      if (starting_after) {\n        params.starting_after = starting_after;\n      }\n\n      const payments = await this.stripe.paymentIntents.list(params);\n      return payments;\n    } catch (error) {\n      console.error('Error fetching payments list:', error);\n      throw new HttpException('Internal server error', HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n  }\n}\n"
    },
    {
      "target": "modules/stripe/products.controller.ts",
      "type": "template",
      "content": "import { Controller, Get, Query, HttpException, HttpStatus } from '@nestjs/common';\nimport { getStripe } from '../../lib/stripe';\nimport type Stripe from 'stripe';\n\n@Controller('products')\nexport class ProductsController {\n  private stripe = getStripe();\n\n  @Get()\n  async getProducts(\n    @Query('limit') limit?: string,\n    @Query('starting_after') starting_after?: string,\n  ): Promise<any> {\n    try {\n      const params: Stripe.ProductListParams = {};\n      if (limit) {\n        const parsed = parseInt(limit, 10);\n        if (!isNaN(parsed)) params.limit = parsed;\n      }\n\n      if (starting_after) {\n        params.starting_after = starting_after;\n      }\n\n      const products = await this.stripe.products.list(params);\n      return products.data; // this returns only product array\n    } catch (error) {\n      console.error('Error fetching products:', error);\n      throw new HttpException(\n        { error: 'Internal server error', details: (error as Error).message },\n        HttpStatus.INTERNAL_SERVER_ERROR\n      );\n    }\n  }\n\n  @Get('product')\n  async getProduct(@Query('product_id') product_id?: string): Promise<any> {\n    try {\n      if (!product_id) {\n        throw new HttpException('product_id is required', HttpStatus.BAD_REQUEST);\n      }\n\n      const product = await this.stripe.products.retrieve(product_id);\n      return product;\n    } catch (error) {\n      console.error('Error fetching product:', error);\n      if (error instanceof HttpException) {\n        throw error;\n      }\n      throw new HttpException(\n        { error: 'Internal server error', details: (error as Error).message },\n        HttpStatus.INTERNAL_SERVER_ERROR\n      );\n    }\n  }\n}\n"
    },
    {
      "target": "modules/stripe/subscriptions.controller.ts",
      "type": "template",
      "content": "import { Controller, Get, Query, HttpException, HttpStatus } from '@nestjs/common';\nimport { getStripe } from '../../lib/stripe';\nimport type Stripe from 'stripe';\n\n@Controller('subscriptions')\nexport class SubscriptionsController {\n  private stripe = getStripe();\n\n  @Get()\n  async getSubscription(@Query('subscription_id') subscription_id?: string): Promise<any> {\n    try {\n      if (!subscription_id) {\n        throw new HttpException('subscription_id is required', HttpStatus.BAD_REQUEST);\n      }\n\n      const subscription = await this.stripe.subscriptions.retrieve(subscription_id);\n      return subscription;\n    } catch (error) {\n      console.error('Error fetching subscription:', error);\n      if (error instanceof HttpException) {\n        throw error;\n      }\n      throw new HttpException(\n        { error: 'Internal server error', details: (error as Error).message },\n        HttpStatus.INTERNAL_SERVER_ERROR\n      );\n    }\n  }\n\n  @Get('list')\n  async getSubscriptionsList(\n    @Query('customer_id') customer_id?: string,\n    @Query('limit') limit?: string,\n    @Query('starting_after') starting_after?: string,\n  ): Promise<any> {\n    try {\n      if (!customer_id) {\n        throw new HttpException('customer_id is required', HttpStatus.BAD_REQUEST);\n      }\n\n      const params: Stripe.SubscriptionListParams = {\n        customer: customer_id,\n      };\n\n      if (limit) {\n        const parsed = parseInt(limit, 10);\n        if (!isNaN(parsed)) params.limit = parsed;\n      }\n\n      if (starting_after) {\n        params.starting_after = starting_after;\n      }\n\n      const subscriptions = await this.stripe.subscriptions.list(params);\n      return subscriptions.data; // return only the subscriptions array\n    } catch (error) {\n      console.error('Error fetching subscriptions list:', error);\n      if (error instanceof HttpException) {\n        throw error;\n      }\n      throw new HttpException(\n        { error: 'Internal server error', details: (error as Error).message },\n        HttpStatus.INTERNAL_SERVER_ERROR\n      );\n    }\n  }\n}\n"
    },
    {
      "target": "modules/stripe/webhook.controller.ts",
      "type": "template",
      "content": "import { Controller, Post, Req, Res} from '@nestjs/common';\nimport { Request, Response } from 'express';\nimport Stripe from 'stripe';\nimport { getStripe } from '../../lib/stripe';\n\n@Controller('webhook')\nexport class WebhookController {\n  private stripe = getStripe();\n\n  @Post()\n  async handleWebhook(@Req() req: Request, @Res() res: Response): Promise<any> {\n    const sig = req.headers['stripe-signature'] as string | undefined;\n    if (!sig) {\n      return res.status(400).json({ error: 'Missing Stripe signature' });\n    }\n\n    const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET!;\n    let event: Stripe.Event;\n\n    try {\n      event = this.stripe.webhooks.constructEvent(req.body, sig, webhookSecret);\n    } catch (err) {\n      console.error('Webhook signature verification failed:', err);\n      return res.status(400).json({ error: 'Webhook verification failed' });\n    }\n\n    try {\n      switch (event.type) {\n        \n        case 'customer.subscription.created':\n        case 'customer.subscription.updated':\n        case 'customer.subscription.deleted': {\n          const subscription = event.data.object as Stripe.Subscription;\n          console.log('Subscription event:', event.type, subscription.id);\n          break;\n        }\n\n        \n        case 'payment_intent.succeeded': {\n          const paymentIntent = event.data.object as Stripe.PaymentIntent;\n          console.log('Payment succeeded:', paymentIntent.id, paymentIntent.amount);\n          break;\n        }\n\n        case 'payment_intent.payment_failed': {\n          const paymentIntent = event.data.object as Stripe.PaymentIntent;\n          console.log('Payment failed:', paymentIntent.id, paymentIntent.last_payment_error);\n          break;\n        }\n\n        case 'charge.refunded': {\n          const charge = event.data.object as Stripe.Charge;\n          console.log('Charge refunded:', charge.id, charge.amount_refunded);\n          break;\n        }\n\n        default:\n          console.log('Unhandled event type:', event.type);\n          break;\n      }\n\n      res.status(200).json({ message: 'Webhook processed successfully' });\n    } catch (err) {\n      console.error('Error handling webhook event:', err);\n      res.status(500).json({ error: 'Internal server error' });\n    }\n  }\n}\n"
    },
    {
      "target": ".env.example",
      "type": "template",
      "content": "# Server Configuration\nPORT=3000\nNODE_ENV=development\n\n# Stripe Configuration\nSTRIPE_SECRET_KEY=sk_test_12345...\nSTRIPE_WEBHOOK_SECRET=whsec_12345\n"
    }
  ],
  "dependencies": [
    "stripe",
    "zod",
    "@nestjs/common",
    "@nestjs/core",
    "@nestjs/platform-express",
    "reflect-metadata",
    "rxjs",
    "@types/express"
  ]
}