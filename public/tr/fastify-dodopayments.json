{
  "name": "fastify-dodopayments",
  "description": "DodoPayments template for Fastify",
  "framework": "fastify",
  "files": [
    {
      "target": "lib/dodopayments.ts",
      "type": "template",
      "content": "import { DodoPayments } from 'dodopayments'\n\nlet dodopaymentsClient: DodoPayments | null = null\n\nexport function getDodoPaymentsClient(): DodoPayments {\n  if (!dodopaymentsClient) {\n    const token = process.env.DODO_PAYMENTS_API_KEY\n    const environment = process.env.DODO_PAYMENTS_ENVIRONMENT as 'live_mode' | 'test_mode'\n\n    if (!token) {\n      throw new Error(`\n        DODO_PAYMENTS_API_KEY environment variable is missing.\n        \n        Please check:\n        1. Your .env file exists in the project root\n        2. The file contains: DODO_PAYMENTS_API_KEY=<your-api-key>\n        3. You've restarted your development server\n        4. No extra quotes or spaces in the .env file\n      `)\n    }\n\n    if (!environment || (environment !== 'live_mode' && environment !== 'test_mode')) {\n      throw new Error('DODO_PAYMENTS_ENVIRONMENT must be either \"live_mode\" or \"test_mode\"')\n    }\n\n    dodopaymentsClient = new DodoPayments({\n      bearerToken: token,\n      environment: environment,\n    })\n  }\n\n  return dodopaymentsClient\n}\n"
    },
    {
      "target": "routes/dodopayments/route.ts",
      "type": "template",
      "content": "// @ts-nocheck\nimport { FastifyInstance } from 'fastify'\nimport checkoutRoutes from './checkout'\nimport customerRoutes from './customer'\nimport paymentsRoutes from './payments'\nimport productsRoutes from './products'\nimport subscriptionsRoutes from './subscriptions'\nimport webhookRoutes from './webhook'\n\nexport default async function dodopaymentsRoutes(fastify: FastifyInstance) {\n  await fastify.register(checkoutRoutes, { prefix: '/checkout' })\n  await fastify.register(customerRoutes, { prefix: '/customer' })\n  await fastify.register(paymentsRoutes, { prefix: '/payments' })\n  await fastify.register(productsRoutes, { prefix: '/products' })\n  await fastify.register(subscriptionsRoutes, { prefix: '/subscriptions' })\n  await fastify.register(webhookRoutes, { prefix: '/webhook' })\n}\n"
    },
    {
      "target": "routes/dodopayments/checkout.ts",
      "type": "template",
      "content": "// @ts-nocheck\nimport { FastifyInstance } from 'fastify'\nimport { z } from 'zod'\nimport { DodoPayments } from 'dodopayments'\nimport { getDodoPaymentsClient } from '../../lib/dodopayments'\n\nexport default async function checkoutRoutes(fastify: FastifyInstance) {\n  const productCartItemSchema = z.object({\n    product_id: z.string().min(1, 'Product ID is required'),\n    quantity: z.number().int().min(1, 'Quantity must be at least 1'),\n    amount: z.number().int().min(0).optional(),\n  })\n\n  const attachExistingCustomerSchema = z.object({\n    customer_id: z.string().min(1, 'Customer ID is required'),\n  })\n\n  const newCustomerSchema = z.object({\n    email: z.string().email('Invalid email format'),\n    name: z.string().min(1, 'Name is required'),\n    phone_number: z.string().optional().nullable(),\n    create_new_customer: z.boolean().optional(),\n  })\n\n  const customerSchema = z.union([attachExistingCustomerSchema, newCustomerSchema])\n\n  const billingAddressSchema = z.object({\n    city: z.string().min(1, 'City is required'),\n    country: z.string().regex(/^[A-Z]{2}$/, 'Country must be a 2-letter uppercase ISO code'),\n    state: z.string().min(1, 'State is required'),\n    street: z.string().min(1, 'Street address is required'),\n    zipcode: z.string().min(1, 'Zipcode is required'),\n  })\n\n  const checkoutSessionSchema = z.object({\n    productCart: z.array(productCartItemSchema).min(1, 'At least one product is required'),\n    customer: customerSchema,\n    billing_address: billingAddressSchema,\n    return_url: z.string().url('Return URL must be a valid URL'),\n    customMetadata: z.record(z.string(), z.string()).optional(),\n  })\n\n  fastify.post('/', async (request, reply) => {\n    try {\n      const validationResult = checkoutSessionSchema.safeParse(request.body)\n      if (!validationResult.success) {\n        return reply.status(400).send({\n          error: 'Validation failed',\n          details: validationResult.error.issues.map((issue) => ({\n            field: issue.path.join('.'),\n            message: issue.message,\n          })),\n        })\n      }\n\n      const { productCart, customer, billing_address, return_url, customMetadata } = validationResult.data\n\n      const session = await getDodoPaymentsClient().checkoutSessions.create({\n        product_cart: productCart,\n        customer: customer,\n        billing_address: billing_address as DodoPayments.Payments.BillingAddress,\n        return_url: return_url,\n        metadata: customMetadata,\n      })\n\n      return reply.send(session)\n    } catch (error) {\n      request.log.error({ err: error }, 'Error in checkout POST handler')\n      return reply.status(500).send({ error: 'Internal server error' })\n    }\n  })\n}\n"
    },
    {
      "target": "routes/dodopayments/customer.ts",
      "type": "template",
      "content": "// @ts-nocheck\nimport { FastifyInstance } from 'fastify'\nimport { z } from 'zod'\nimport { getDodoPaymentsClient } from '../../lib/dodopayments'\n\nexport default async function customerRoutes(fastify: FastifyInstance) {\n  const customerCreateSchema = z.object({\n    email: z.string().email('Invalid email format'),\n    name: z.string().min(1, 'Name is required'),\n    phone_number: z.string().optional().nullable(),\n  })\n\n  const customerUpdateSchema = z.object({\n    email: z.string().email('Invalid email format').optional(),\n    name: z.string().min(1, 'Name is required').optional(),\n    phone_number: z.string().optional().nullable(),\n  })\n\n  fastify.get('/', async (request, reply) => {\n    try {\n      const { customer_id } = request.query as Record<string, any>\n      if (!customer_id || typeof customer_id !== 'string') {\n        return reply.status(400).send({ error: 'customer_id is required' })\n      }\n      const customer = await getDodoPaymentsClient().customers.retrieve(customer_id)\n      return reply.send(customer)\n    } catch (error) {\n      request.log.error({ err: error }, 'Error fetching customer')\n      return reply.status(500).send({ error: 'Internal server error' })\n    }\n  })\n\n  fastify.post('/', async (request, reply) => {\n    try {\n      const validationResult = customerCreateSchema.safeParse(request.body)\n      if (!validationResult.success) {\n        return reply.status(400).send({\n          error: 'Validation failed',\n          details: validationResult.error.issues.map((issue) => ({\n            field: issue.path.join('.'),\n            message: issue.message,\n          })),\n        })\n      }\n\n      const customer = await getDodoPaymentsClient().customers.create(validationResult.data)\n      return reply.send(customer)\n    } catch (error) {\n      request.log.error({ err: error }, 'Error creating customer')\n      return reply.status(500).send({ error: 'Internal server error' })\n    }\n  })\n\n  fastify.put('/', async (request, reply) => {\n    try {\n      const { customer_id } = request.query as Record<string, any>\n      if (!customer_id || typeof customer_id !== 'string') {\n        return reply.status(400).send({ error: 'customer_id is required' })\n      }\n\n      const validationResult = customerUpdateSchema.safeParse(request.body)\n      if (!validationResult.success) {\n        return reply.status(400).send({\n          error: 'Validation failed',\n          details: validationResult.error.issues.map((issue) => ({\n            field: issue.path.join('.'),\n            message: issue.message,\n          })),\n        })\n      }\n\n      const customer = await getDodoPaymentsClient().customers.update(customer_id, validationResult.data)\n      return reply.send(customer)\n    } catch (error) {\n      request.log.error({ err: error }, 'Error updating customer')\n      return reply.status(500).send({ error: 'Internal server error' })\n    }\n  })\n\n  fastify.get('/subscriptions', async (request, reply) => {\n    try {\n      const { customer_id } = request.query as Record<string, any>\n      if (!customer_id || typeof customer_id !== 'string') {\n        return reply.status(400).send({ error: 'customer_id is required' })\n      }\n\n      const subscriptions = await getDodoPaymentsClient().subscriptions.list({\n        customer_id,\n      })\n      return reply.send(subscriptions)\n    } catch (error) {\n      request.log.error({ err: error }, 'Error fetching customer subscriptions')\n      return reply.status(500).send({ error: 'Internal server error' })\n    }\n  })\n\n  fastify.get('/payments', async (request, reply) => {\n    try {\n      const { customer_id } = request.query as Record<string, any>\n      if (!customer_id || typeof customer_id !== 'string') {\n        return reply.status(400).send({ error: 'customer_id is required' })\n      }\n\n      const payments = await getDodoPaymentsClient().payments.list({\n        customer_id,\n      })\n      return reply.send(payments)\n    } catch (error) {\n      request.log.error({ err: error }, 'Error fetching customer payments')\n      return reply.status(500).send({ error: 'Internal server error' })\n    }\n  })\n}\n"
    },
    {
      "target": "routes/dodopayments/payments.ts",
      "type": "template",
      "content": "// @ts-nocheck\nimport { FastifyInstance } from 'fastify'\nimport { getDodoPaymentsClient } from '../../lib/dodopayments'\n\nexport default async function paymentsRoutes(fastify: FastifyInstance) {\n  fastify.get('/', async (request, reply) => {\n    try {\n      const { payment_id } = request.query as Record<string, any>\n      if (!payment_id || typeof payment_id !== 'string') {\n        return reply.status(400).send({ error: 'payment_id is required' })\n      }\n      const payment = await getDodoPaymentsClient().payments.retrieve(payment_id)\n      return reply.send(payment)\n    } catch (error) {\n      request.log.error({ err: error }, 'Error fetching payment')\n      return reply.status(500).send({ error: 'Internal server error' })\n    }\n  })\n\n  fastify.get('/list', async (request, reply) => {\n    try {\n      const { customer_id, limit, starting_after } = request.query as Record<string, any>\n      const params: any = {}\n      if (typeof customer_id === 'string') params.customer_id = customer_id\n      if (typeof limit === 'string') params.limit = parseInt(limit)\n      if (typeof starting_after === 'string') params.starting_after = starting_after\n\n      const payments = await getDodoPaymentsClient().payments.list(params)\n      return reply.send(payments)\n    } catch (error) {\n      request.log.error({ err: error }, 'Error fetching payments list')\n      return reply.status(500).send({ error: 'Internal server error' })\n    }\n  })\n}\n"
    },
    {
      "target": "routes/dodopayments/products.ts",
      "type": "template",
      "content": "// @ts-nocheck\nimport { FastifyInstance } from 'fastify'\nimport { getDodoPaymentsClient } from '../../lib/dodopayments'\n\nexport default async function productsRoutes(fastify: FastifyInstance) {\n  fastify.get('/', async (request, reply) => {\n    try {\n      const { limit, starting_after } = request.query as Record<string, any>\n      const params: any = {}\n      if (typeof limit === 'string') params.limit = parseInt(limit)\n      if (typeof starting_after === 'string') params.starting_after = starting_after\n\n      const products = await getDodoPaymentsClient().products.list(params)\n      return reply.send(products)\n    } catch (error) {\n      request.log.error({ err: error }, 'Error fetching products')\n      return reply.status(500).send({ error: 'Internal server error' })\n    }\n  })\n\n  fastify.get('/product', async (request, reply) => {\n    try {\n      const { product_id } = request.query as Record<string, any>\n      if (!product_id || typeof product_id !== 'string') {\n        return reply.status(400).send({ error: 'product_id is required' })\n      }\n\n      const product = await getDodoPaymentsClient().products.retrieve(product_id)\n      return reply.send(product)\n    } catch (error) {\n      request.log.error({ err: error }, 'Error fetching product')\n      return reply.status(500).send({ error: 'Internal server error' })\n    }\n  })\n}\n"
    },
    {
      "target": "routes/dodopayments/subscriptions.ts",
      "type": "template",
      "content": "import { FastifyInstance } from 'fastify'\nimport { getDodoPaymentsClient } from '../../lib/dodopayments'\n\nexport default async function subscriptionsRoutes(fastify: FastifyInstance) {\n  fastify.get('/', async (request, reply) => {\n    try {\n      const { subscription_id } = request.query as Record<string, any>\n      if (!subscription_id || typeof subscription_id !== 'string') {\n        return reply.status(400).send({ error: 'subscription_id is required' })\n      }\n      const subscription = await getDodoPaymentsClient().subscriptions.retrieve(subscription_id)\n      return reply.send(subscription)\n    } catch (error) {\n      request.log.error({ err: error }, 'Error fetching subscription')\n      return reply.status(500).send({ error: 'Internal server error' })\n    }\n  })\n\n  fastify.get('/list', async (request, reply) => {\n    try {\n      const { customer_id, limit, starting_after } = request.query as Record<string, any>\n      const params: any = {}\n      if (typeof customer_id === 'string') params.customer_id = customer_id\n      if (typeof limit === 'string') params.limit = parseInt(limit)\n      if (typeof starting_after === 'string') params.starting_after = starting_after\n\n      const subscriptions = await getDodoPaymentsClient().subscriptions.list(params)\n      return reply.send(subscriptions)\n    } catch (error) {\n      request.log.error({ err: error }, 'Error fetching subscriptions list')\n      return reply.status(500).send({ error: 'Internal server error' })\n    }\n  })\n}\n"
    },
    {
      "target": "routes/dodopayments/webhook.ts",
      "type": "template",
      "content": "\n// @ts-nocheck\nimport { FastifyInstance } from 'fastify'\nimport { Webhook } from 'standardwebhooks'\n\nexport default async function webhookRoutes(fastify: FastifyInstance) {\n  const webhook = new Webhook(process.env.DODO_PAYMENTS_WEBHOOK_KEY!)\n\n  fastify.post('/', {\n    // Note: To get the raw body reliably, register `fastify-raw-body` in your Fastify app:\n    // await fastify.register(import('fastify-raw-body'), { field: 'rawBody', global: false, encoding: 'utf8', runFirst: true })\n    // and enable it for this route via `config: { rawBody: true }`.\n    config: { rawBody: true }\n  }, async (request, reply) => {\n    try {\n      // Prefer rawBody provided by fastify-raw-body; fallback to re-serializing parsed body\n      const rawBody: any = (request as any).rawBody ?? JSON.stringify(request.body ?? {})\n\n      const webhookHeaders = {\n        'webhook-id': (request.headers['webhook-id'] as string) || '',\n        'webhook-signature': (request.headers['webhook-signature'] as string) || '',\n        'webhook-timestamp': (request.headers['webhook-timestamp'] as string) || '',\n      }\n\n      await webhook.verify(rawBody, webhookHeaders)\n      const payload = typeof rawBody === 'string' ? JSON.parse(rawBody) : request.body\n\n      // Emit logs for reference; users can replace with their business logic\n      if (payload.data.payload_type === 'Subscription') {\n        switch (payload.type) {\n          case 'subscription.active':\n          case 'subscription.failed':\n          case 'subscription.cancelled':\n          case 'subscription.renewed':\n          case 'subscription.on_hold':\n            request.log.info({ payload }, `Received ${payload.type}`)\n            break\n          default:\n            request.log.info({ payload }, 'Unknown subscription event')\n        }\n      } else if (payload.data.payload_type === 'Payment') {\n        switch (payload.type) {\n          case 'payment.succeeded':\n          case 'payment.failed':\n          case 'payment.refunded':\n            request.log.info({ payload }, `Received ${payload.type}`)\n            break\n          default:\n            request.log.info({ payload }, 'Unknown payment event')\n        }\n      }\n\n      return reply.status(200).send({ message: 'Webhook processed successfully' })\n    } catch (error) {\n      request.log.error({ err: error }, 'Webhook verification failed')\n      return reply.status(400).send({ error: 'Webhook verification failed' })\n    }\n  })\n}\n"
    },
    {
      "target": ".env.example",
      "type": "template",
      "content": "# DodoPayments Configuration\nDODO_PAYMENTS_API_KEY=your_api_key_here\nDODO_PAYMENTS_ENVIRONMENT=test_mode\nDODO_PAYMENTS_WEBHOOK_KEY=your_webhook_key_here\n\n# Server Configuration\nPORT=3000\nNODE_ENV=development\n"
    }
  ],
  "dependencies": [
    "dodopayments",
    "standardwebhooks",
    "zod",
    "fastify",
    "fastify-raw-body"
  ]
}