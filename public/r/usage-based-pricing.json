{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "usage-based-pricing",
  "type": "registry:block",
  "title": "Usage Based Pricing",
  "description": "A usage based pricing component",
  "dependencies": [
    "motion"
  ],
  "registryDependencies": [
    "card",
    "utils"
  ],
  "files": [
    {
      "path": "src/registry/billingsdk/usage-based-pricing.tsx",
      "content": "\"use client\"\r\n\r\nimport { useEffect, useLayoutEffect, useMemo, useRef, useState, type ReactNode } from \"react\"\r\nimport { motion, useSpring, useTransform, useMotionValueEvent } from \"motion/react\"\r\nimport { cn } from \"@/lib/utils\"\r\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from \"@/components/ui/card\"\r\n\r\nexport type UsageBasedPricingProps = {\r\n  className?: string\r\n  min?: number\r\n  max?: number\r\n  step?: number\r\n  snapTo?: number\r\n  value?: number\r\n  defaultValue?: number\r\n  onChange?: (value: number) => void\r\n  onChangeEnd?: (value: number) => void\r\n  currency?: string\r\n  basePrice?: number\r\n  includedCredits?: number\r\n  unitPricePerCredit?: number\r\n  title?: string\r\n  subtitle?: string\r\n}\r\n\r\nfunction clamp(v: number, min: number, max: number) {\r\n  return Math.min(Math.max(v, min), max)\r\n}\r\nfunction formatNumber(n: number) {\r\n  return new Intl.NumberFormat(undefined, { maximumFractionDigits: 0 }).format(n)\r\n}\r\n\r\nexport function UsageBasedPricing({\r\n  className,\r\n  min = 4000,\r\n  max = 25001,\r\n  step = 1,\r\n  snapTo,\r\n  value: valueProp,\r\n  defaultValue = 4000,\r\n  onChange,\r\n  onChangeEnd,\r\n  currency = \"$\",\r\n  basePrice = 39.99,\r\n  includedCredits = 4000,\r\n  title = \"Pay as you use pricing\",\r\n  subtitle = \"Start with a flat monthly rate that includes 4,000 credits.\",\r\n}: UsageBasedPricingProps) {\r\n  const isControlled = typeof valueProp === 'number'\r\n  const [uncontrolled, setUncontrolled] = useState(clamp(defaultValue, min, max))\r\n  const value = isControlled ? clamp(valueProp as number, min, max) : uncontrolled\r\n  const trackRef = useRef<HTMLDivElement | null>(null)\r\n  const [trackWidth, setTrackWidth] = useState(0)\r\n  const [posPct, setPosPct] = useState(() => ((value - min) / (max - min)) * 100)\r\n  const animRef = useRef<number | null>(null)\r\n  const animStartRef = useRef<number>(0)\r\n  const animFromPctRef = useRef<number>(0)\r\n  const animToPctRef = useRef<number>(0)\r\n  const animDurationMs = 300\r\n  const isPointerDownRef = useRef(false)\r\n  const hasMovedRef = useRef(false)\r\n  const suppressClickRef = useRef(false)\r\n\r\n  // measure track width for ticks\r\n  useLayoutEffect(() => {\r\n    const el = trackRef.current\r\n    if (!el) return\r\n    const update = () => setTrackWidth(el.clientWidth)\r\n    update()\r\n    const ro = new ResizeObserver(update)\r\n    ro.observe(el)\r\n    window.addEventListener('resize', update)\r\n    return () => {\r\n      ro.disconnect()\r\n      window.removeEventListener('resize', update)\r\n    }\r\n  }, [])\r\n\r\n  const price = useMemo(() => {\r\n    // Pricing: basePrice covers includedCredits. For every additional 1,000 credits, add $10.\r\n    const extra = Math.max(0, value - includedCredits)\r\n    const thousandsOver = Math.ceil(extra / 1000)\r\n    const extraCost = thousandsOver * 10\r\n    return basePrice + extraCost\r\n  }, [value, includedCredits, basePrice])\r\n\r\n  const priceSpring = useSpring(price, { stiffness: 140, damping: 18, mass: 0.6 })\r\n  useEffect(() => {\r\n    priceSpring.set(price)\r\n  }, [price, priceSpring])\r\n  const priceRounded = useTransform(priceSpring, (p: number) => Math.max(0, p))\r\n  const [priceText, setPriceText] = useState(price.toFixed(2))\r\n  useMotionValueEvent(priceRounded, \"change\", (v) => {\r\n    setPriceText((v as number).toFixed(2))\r\n  })\r\n\r\n  // keep visual position in sync with external value changes (controlled)\r\n  useEffect(() => {\r\n    // avoid interrupting during user interactions\r\n    if (isPointerDownRef.current) return\r\n    if (animRef.current) return\r\n    const pctFromValue = ((value - min) / (max - min)) * 100\r\n    setPosPct(clamp(pctFromValue, 0, 100))\r\n  }, [value, min, max])\r\n\r\n  const pct = posPct\r\n  const tickCount = useMemo(() => Math.max(80, Math.floor((trackWidth || 1) / 6)), [trackWidth])\r\n  const currentTickIndexFloat = useMemo(() => (posPct / 100) * (tickCount - 1), [posPct, tickCount])\r\n\r\n  const commitValue = (v: number, fireEnd = false) => {\r\n    const clamped = clamp(v, min, max)\r\n    if (!isControlled) setUncontrolled(clamped)\r\n    onChange?.(clamped)\r\n    if (fireEnd) onChangeEnd?.(clamped)\r\n  }\r\n\r\n  const quantize = (raw: number) => {\r\n    const stepped = Math.round(raw / step) * step\r\n    return clamp(stepped, min, max)\r\n  }\r\n\r\n  const onPointerDown = (e: React.PointerEvent<HTMLDivElement>) => {\r\n    e.currentTarget.setPointerCapture?.(e.pointerId)\r\n    isPointerDownRef.current = true\r\n    hasMovedRef.current = false\r\n    // do not update immediately; wait for move to avoid jump on simple click\r\n  }\r\n  const onPointerMove = (e: React.PointerEvent<HTMLDivElement>) => {\r\n    if (e.buttons !== 1 || !isPointerDownRef.current) return\r\n    hasMovedRef.current = true\r\n    updateFromEvent(e, false)\r\n  }\r\n  const onPointerUp = (e: React.PointerEvent<HTMLDivElement>) => {\r\n    // Only commit if there was a drag; a simple click will be handled by onClick animation\r\n    if (hasMovedRef.current) {\r\n      updateFromEvent(e, true)\r\n      // skip the trailing synthetic click fired after a drag\r\n      suppressClickRef.current = true\r\n    }\r\n    e.currentTarget.releasePointerCapture?.(e.pointerId)\r\n    isPointerDownRef.current = false\r\n    hasMovedRef.current = false\r\n  }\r\n  const onPointerCancel = (e: React.PointerEvent<HTMLDivElement>) => {\r\n    e.currentTarget.releasePointerCapture?.(e.pointerId)\r\n    isPointerDownRef.current = false\r\n    hasMovedRef.current = false\r\n  }\r\n  // easing function for dot click animation\r\n  const easeOutCubic = (t: number) => 1 - Math.pow(1 - t, 3)\r\n  // animate to target value (used by clickable dots)\r\n  const animateTo = (targetValue: number) => {\r\n    // cancel any existing animation\r\n    if (animRef.current) cancelAnimationFrame(animRef.current)\r\n    const tnorm = (targetValue - min) / (max - min)\r\n    animFromPctRef.current = posPct\r\n    animToPctRef.current = clamp(tnorm * 100, 0, 100)\r\n    animStartRef.current = performance.now()\r\n    const step = (now: number) => {\r\n      const elapsed = now - animStartRef.current\r\n      const p = Math.min(1, elapsed / animDurationMs)\r\n      const k = easeOutCubic(p)\r\n      const currPct = animFromPctRef.current + (animToPctRef.current - animFromPctRef.current) * k\r\n      setPosPct(currPct)\r\n      // live update the value with 100/snapTo increments during animation\r\n      const liveValue = min + (currPct / 100) * (max - min)\r\n      const moveSnap = (snapTo && snapTo > 0) ? snapTo : 100\r\n      let next = Math.round(liveValue / moveSnap) * moveSnap\r\n      next = clamp(next, min, max)\r\n      commitValue(next, false)\r\n      if (p < 1) {\r\n        animRef.current = requestAnimationFrame(step)\r\n      } else {\r\n        // finalize exactly on target and fire end\r\n        commitValue(targetValue, true)\r\n        animRef.current = null\r\n      }\r\n    }\r\n    animRef.current = requestAnimationFrame(step)\r\n  }\r\n  const updateFromEvent = (e: React.PointerEvent<HTMLDivElement>, isEnd: boolean) => {\r\n    if (!trackRef.current) return\r\n    const rect = trackRef.current.getBoundingClientRect()\r\n    const x = clamp(e.clientX - rect.left, 0, rect.width)\r\n    const t = x / rect.width\r\n    const raw = min + t * (max - min)\r\n    // update transient visual percent immediately\r\n    setPosPct(t * 100)\r\n    // During move: update visuals and value in live increments (default 100 or snapTo)\r\n    if (!isEnd) {\r\n      const moveSnap = (snapTo && snapTo > 0) ? snapTo : 100\r\n      let next = Math.round(raw / moveSnap) * moveSnap\r\n      next = clamp(next, min, max)\r\n      commitValue(next, false)\r\n      return\r\n    }\r\n    // On end: snap to snapTo (if provided) or to step (>1) else to 100\r\n    let next = raw\r\n    if (snapTo && snapTo > 0) {\r\n      next = Math.round(raw / snapTo) * snapTo\r\n    } else if (step && step > 1) {\r\n      next = quantize(raw)\r\n    } else {\r\n      next = Math.round(raw / 100) * 100\r\n    }\r\n    commitValue(next, true)\r\n  }\r\n\r\n  // Positions for labels centered under first and last 1000-multiple dots\r\n  const firstThousand = useMemo(() => Math.ceil(min / 1000) * 1000, [min])\r\n  const lastThousand = useMemo(() => Math.floor(max / 1000) * 1000, [max])\r\n  const startLabel = `${formatNumber(firstThousand)} credits`\r\n  const endLabel = `${formatNumber(lastThousand)} credits`\r\n\r\n  // Keyboard Accessibility\r\n  const handleKeyDown = (e: React.KeyboardEvent<HTMLDivElement>) => {\r\n    let delta = 0\r\n    const baseStep = snapTo && snapTo > 0 ? snapTo : 100\r\n    switch (e.key) {\r\n      case 'ArrowLeft':\r\n      case 'ArrowDown':\r\n        delta = -(e.shiftKey ? baseStep * 5 : baseStep)\r\n        break\r\n      case 'ArrowRight':\r\n      case 'ArrowUp':\r\n        delta = (e.shiftKey ? baseStep * 5 : baseStep)\r\n        break\r\n      case 'Home':\r\n        commitValue(Math.round(min / baseStep) * baseStep, true)\r\n        e.preventDefault()\r\n        return\r\n      case 'End':\r\n        commitValue(Math.round(max / baseStep) * baseStep, true)\r\n        e.preventDefault()\r\n        return\r\n      default:\r\n        return\r\n    }\r\n    e.preventDefault()\r\n    const next = clamp(value + delta, min, max)\r\n    const snapped = Math.round(next / baseStep) * baseStep\r\n    commitValue(snapped, true)\r\n  }\r\n\r\n  return (\r\n    <Card className={cn(\"w-full max-w-3xl min-w-lg mx-auto\", className)}>\r\n      <CardHeader className=\"text-left\">\r\n        <CardTitle>{title}</CardTitle>\r\n        <CardDescription>{subtitle}</CardDescription>\r\n      </CardHeader>\r\n      <CardContent>\r\n        <div className=\"flex flex-col items-center gap-2 mt-4\">\r\n          <div className=\"flex items-baseline gap-1\">\r\n            <span className=\"text-4xl font-bold tabular-nums\">{currency}{priceText}</span>\r\n            <span className=\"text-muted-foreground text-sm\">/mo</span>\r\n          </div>\r\n          <p className=\"text-xs text-muted-foreground\">\r\n            {formatNumber(value)} credits per month\r\n          </p>\r\n        </div>\r\n\r\n        <div className=\"space-y-6\">\r\n          <div className=\"mb-6 relative h-0\">\r\n            <div className=\"absolute -top-10\" style={{ left: `${pct}%` }}>\r\n              <div className=\"-translate-x-1/2 rounded-md border bg-background px-3 py-1 text-xs shadow-sm\">\r\n                {formatNumber(value)}\r\n              </div>\r\n            </div>\r\n          </div>\r\n\r\n          <div\r\n            ref={trackRef}\r\n            className=\"relative h-12 select-none\"\r\n            onPointerDown={onPointerDown}\r\n            onPointerMove={onPointerMove}\r\n            onPointerUp={onPointerUp}\r\n            onPointerCancel={onPointerCancel}\r\n            onClick={(e) => {\r\n              if (suppressClickRef.current) {\r\n                suppressClickRef.current = false\r\n                return\r\n              }\r\n              if (!trackRef.current) return\r\n              const rect = trackRef.current.getBoundingClientRect()\r\n              const x = clamp(e.clientX - rect.left, 0, rect.width)\r\n              const t = x / rect.width\r\n              const raw = min + t * (max - min)\r\n              const baseSnap = (snapTo && snapTo > 0) ? snapTo : 100\r\n              const target = clamp(Math.round(raw / baseSnap) * baseSnap, min, max)\r\n              animateTo(target)\r\n            }}\r\n          >\r\n            {/* Animated ruler ticks */}\r\n            <div className=\"pointer-events-none absolute inset-0\">\r\n              {Array.from({ length: tickCount }).map((_, i) => {\r\n                const left = (i / (tickCount - 1)) * 100\r\n                const distFloat = Math.abs(currentTickIndexFloat - i)\r\n                const base = 10\r\n                const peak = 12\r\n                const spread = 2\r\n                const factor = Math.max(0, 1 - distFloat / spread)\r\n                const height = base + peak * factor\r\n                let color = 'bg-muted-foreground/40'\r\n                if (distFloat < 0.5) color = 'bg-primary'\r\n                else if (distFloat < 1.5) color = 'bg-primary/90'\r\n                else if (distFloat < 2.5) color = 'bg-primary/70'\r\n                const widthClass = distFloat < 0.5\r\n                  ? 'w-[3px]'\r\n                  : (distFloat < 3.5 ? 'w-[2px]' : 'w-px')\r\n                return (\r\n                  <motion.div\r\n                    key={i}\r\n                    className={`absolute top-1/2 -translate-y-full ${widthClass} rounded-full ${color}`}\r\n                    style={{ left: `${left}%` }}\r\n                    animate={{ height }}\r\n                    transition={{ type: 'spring', stiffness: 260, damping: 28 }}\r\n                  />\r\n                )\r\n              })}\r\n            </div>\r\n\r\n            {/* Clickable dots every 1000 credits */}\r\n            <div className=\"pointer-events-auto absolute inset-0\">\r\n              {(() => {\r\n                const first = Math.ceil(min / 1000) * 1000\r\n                const dots: ReactNode[] = []\r\n                for (let v = first; v <= max; v += 1000) {\r\n                  const t = (v - min) / (max - min)\r\n                  const left = `${t * 100}%`\r\n                  const isActive = Math.round(value) === v\r\n                  dots.push(\r\n                    <div\r\n                      key={`dot-${v}`}\r\n                      role=\"button\"\r\n                      tabIndex={0}\r\n                      aria-label={`${v.toLocaleString()} credits`}\r\n                      onClick={() => { animateTo(v) }}\r\n                      onKeyDown={(e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); animateTo(v) } }}\r\n                      className={`absolute rounded-full outline-none ${isActive ? 'bg-primary' : 'bg-muted-foreground/70'} focus:ring-2 focus:ring-primary/50`}\r\n                      style={{\r\n                        left,\r\n                        top: 'calc(50% + 14px)',\r\n                        transform: 'translateX(-50%)',\r\n                        width: '4px',\r\n                        height: '4px',\r\n                        cursor: 'pointer',\r\n                      }}\r\n                    />\r\n                  )\r\n                }\r\n                return dots\r\n              })()}\r\n            </div>\r\n\r\n            <div\r\n              className=\"absolute top-1/2 -translate-y-1/2\"\r\n              style={{ left: `${pct}%` }}\r\n            >\r\n              <div\r\n                role=\"slider\"\r\n                aria-valuemin={min}\r\n                aria-valuemax={max}\r\n                aria-valuenow={value}\r\n                aria-valuetext={`${formatNumber(value)} credits`}\r\n                tabIndex={0}\r\n                onKeyDown={handleKeyDown}\r\n                className=\"sr-only\"\r\n              />\r\n            </div>\r\n          </div>\r\n\r\n          <div className=\"flex justify-between text-xs text-muted-foreground px-1\">\r\n            <span>{startLabel}</span>\r\n            <span>{endLabel}</span>\r\n          </div>\r\n        </div>\r\n      </CardContent>\r\n    </Card>\r\n  )\r\n}\r\n\r\nexport default UsageBasedPricing\r\n",
      "type": "registry:component",
      "target": "components/billingsdk/usage-based-pricing.tsx"
    },
    {
      "path": "src/registry/billingsdk/demo/usage-based-pricing-demo.tsx",
      "content": "\"use client\"\r\n\r\nimport { useState } from \"react\"\r\nimport { UsageBasedPricing } from \"@/components/billingsdk/usage-based-pricing\"\r\n\r\nexport function UsageBasedPricingDemo() {\r\n  const [credits, setCredits] = useState(4000)\r\n  return (\r\n    <div className=\"flex flex-1 flex-col items-center justify-center text-center space-y-6\">\r\n      <UsageBasedPricing\r\n        className=\"w-full max-w-5xl\"\r\n        min={4000}\r\n        max={25001}\r\n        snapTo={100}\r\n        currency=\"$\"\r\n        basePrice={39.99}\r\n        includedCredits={4000}\r\n        value={credits}\r\n        onChange={setCredits}\r\n        onChangeEnd={(v) => console.log(\"Committed:\", v)}\r\n        title=\"Pay-as-you-use pricing\"\r\n        subtitle=\"Start with a flat monthly rate that includes 4,000 credits.\"\r\n      />\r\n      <div className=\"text-xs text-muted-foreground\">Current value: {credits.toLocaleString()} credits</div>\r\n    </div>\r\n  )\r\n}\r\n",
      "type": "registry:component",
      "target": "components/usage-based-pricing-demo.tsx"
    }
  ]
}